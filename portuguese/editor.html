<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet"> 
    <meta name="googlebot" content="noindex, nofollow">

    <title>Video editor</title>
     
 
<link rel="icon" href="https://raw.githubusercontent.com/manyresources/resourcespage/main/logos/newlogo/favicon.ico" type="image/x-icon">
 
<link rel="stylesheet" href="../design2/expressions.css">

<style> 
#general-header{display:none};
.header-menu{top:0;width:100%;user-select:none}.header-menu,.side-menu,.side-menu.active{background-color:rgb(25,25,25)}
.header-menu{display:flex;z-index:4;justify-content:space-between;align-items:center;color:#333;padding:10px 20px;height:45px;box-shadow:0 2px 5px rgba(0,0,0,.3);box-sizing:border-box} 

.logo-container-menu{display:flex;align-items:center;justify-content:center}.logo-container-menu p{margin:auto;font-size:18px;font-weight:bolder;color:rgb(245,245,245)}.logo-menu{height:30px;margin-right:10px;border-radius:50%;object-fit:cover}#languageModal,.side-menu{position:fixed;height:100%}.hamburger{font-size:25px;font-weight:700;cursor:pointer;padding:5px;color:rgb(255,255,255);}.side-menu{top:45px;left:-100%;width:150px;color:#444;padding:20px;box-shadow:2px 0 5px rgba(0,0,0,.3);transition:left .3s;z-index:12}.side-menu.active{left:0}#openModalBtn,#save-lang{background-color:#7c55e6;color:#fff}.side-menu nav ul{list-style:none;padding:0}.side-menu nav ul li{margin:20px 0;padding:10px 5px}.side-menu nav ul li a{color:#fff;text-decoration:none;font-size:18px}

 

 
 


 
.plus-modal-description{margin-bottom:15px;color:#666;font-size:14px}
.plus-textarea{width:100%;min-height:100px;padding:10px;border:1px solid #ccc;border-radius:4px;font-size:14px;resize:vertical;margin-bottom:15px;position:relative}
 
.mention-menu{display:none;position:absolute;background:#fff;border:1px solid #ccc;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,.15);max-height:100px;overflow-y:auto;z-index:1002;min-width:150px}
.mention-menu-item{padding:8px 12px;cursor:pointer;font-size:14px;color:#333}
.mention-menu-item:hover{background-color:#f0f0f0}
.mention-menu-item.selected{background-color:#7c55e6;color:#fff}

 
 
 

 
 
/*ver el 7_3.html*/
.plus-modal-content {
    width: calc(100% - 30px);  /* ancho con margen */
    max-width: 500px;           /* si quieres limitar ancho */
    background: rgb(50, 65, 69);
    color: white;
    display: flex;
    flex-direction: column;
    padding: 0; 
    height: calc(100vh - 180px);
    min-height: 150px;
    border-radius: 15px;
    overflow-y: auto;
    box-sizing: border-box;     /* importante para que padding no desborde */
    margin: 0;                   /* asegurarse de que no se rompa el centrado */
}


.plus-modal-header { 
    background-color: rgb(25, 25, 25);
    display:none; 
    justify-content: center;
    align-items: center;
    position: relative;
    padding: 6px 15px;  
}

.plus-modal-title {
    flex: 1;
    text-align: center;
    margin: 0;
    font-size:16px;
    color:#fff; 
}

.plus-modal-close {
    display:none;
    position: absolute !important;
    top: 0;
    right: 5px;
    width: 24px;
    height: 24px;
    font-size: 26px;
    color: white;
    background: transparent;
    border: none;
    cursor: pointer;
}

 

.script-panel-container { flex: 1; display: flex; flex-direction: column; gap: 5px; overflow-y: auto; padding: 5px 10px 0 10px; background: rgb(50, 65, 69);}

.chat-message.user {
  position: relative; /* para que el bot√≥n se posicione respecto al p√°rrafo */
  padding: 10px 35px 10px 10px; /* espacio a la derecha para el bot√≥n */
  background-color: rgba(196, 205, 208);
  color:rgb(25,25,25); 
  border-radius: 8px;
  margin-bottom: 10px;
  text-align: center; /* centra solo el texto horizontalmente */
  word-wrap: break-word;
  box-shadow:
    0 0 0 1px rgba(255, 255, 255, 0.6),
    0 0 6px 2px rgba(255, 255, 255, 0.4);
}

.close-btn {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background-color: rgb(25,25,25);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-weight: bold;
  font-size: 14px;
}


.chat-message.destinatario {
    position: relative; /* para que el bot√≥n se posicione respecto al p√°rrafo */
  padding: 10px 35px 10px 10px; /* espacio a la derecha para el bot√≥n */
  background-color: rgb(240,102,84);
  color:rgb(25,25,25); 
  border-radius: 8px;
  margin-bottom: 10px;
  text-align: center; /* centra solo el texto horizontalmente */
  word-wrap: break-word;
}
 

/*new*/


.tabs-menu-container-settings {
    display: flex;
    background: rgb(35, 45, 48);
    border-bottom: 1px solid rgba(255,255,255,0.2);
}

.tab-button-active-settings,
.tab-button-inactive-settings {
    flex: 1;
    padding: 12px;
    background: transparent;
    border: none;
    color: rgba(255,255,255,0.6);
    font-size: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.tab-button-active-settings {
    color: #fff;
    font-weight: bold;
    border-bottom: 3px solid #7c55e6;
}

.tab-button-inactive-settings:hover {
    background: rgba(255,255,255,0.05);
}

.tab-content-team-settings, 
.tab-content-general-settings,
.tab-content-advanced-settings {
    display: none !important;  /* fuerza ocultar por defecto */
    flex: 1 1 auto;
    flex-direction: column;
    justify-content: flex-start;
    align-items: stretch;
    overflow-y: auto;
    min-height: 0;
    gap: 5px;
}

.tab-content-advanced-settings{
	justify-content: center;
}

.tab-content-team-settings.active, 
.tab-content-general-settings.active,
.tab-content-advanced-settings.active {
    display: flex !important;  /* fuerza mostrar solo el activo */
}

.tab-text-general-settings,
.tab-text-advanced-settings {
    font-size: 22px;
    font-weight: bold;
    color: rgba(255,255,255,0.8);
    text-align: center;
}




/*segundo bloque*/

.tab-loader {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin-top: 30px;
}

 
.donut {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 6px solid rgba(255, 255, 255);  
    border-top: 6px solid #7c55e6;  
    animation: spin 1s linear infinite;
}

 
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
 
/* Modal de error (fondo rojo) */
.error-modal-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);z-index:2000}
.error-modal-content{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#f00;padding:20px;border-radius:8px;width:90%;max-width:400px;color:#fff}

.error-modal-content{
  background: rgba(25, 40, 60, 0.55);  
  padding: 20px;
  border-radius: 12px;  
  box-sizing: border-box; 
   color:white;

 
  backdrop-filter: blur(10px) saturate(140%);
  -webkit-backdrop-filter: blur(10px) saturate(140%);

   
  border: 1px solid rgba(255, 255, 255, 0.25);

   
  box-shadow:
    0 0 20px rgba(0, 0, 0, 0.45),
    inset 0 1px 2px rgba(255, 255, 255, 0.2);

   
  background-image: linear-gradient(
    rgba(255,255,255,0.1),
    rgba(0,0,0,0.2)
  );
}


.error-modal-header{display:flex;justify-content:flex-end;margin:0}
.error-modal-close{background:0 0;border:none;font-size:24px;cursor:pointer;color:#fff}
.error-modal-close:hover{opacity:.8}
.error-modal-message{font-size:16px;text-align:center;margin:0}

/* Modal de confirmaci√≥n */
.confirm-modal-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);z-index:2000}
.confirm-modal-content{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#fff;padding:20px;border-radius:8px;width:90%;max-width:400px}
.confirm-modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}
.confirm-modal-header h3{margin:0;color:#333}
.confirm-modal-close{background:0 0;border:none;font-size:24px;cursor:pointer;color:#666}
.confirm-modal-close:hover{color:#000}
.confirm-modal-message{font-size:16px;text-align:center;margin-bottom:20px;color:#333}
.confirm-modal-buttons{display:flex;gap:10px;justify-content:center}
.confirm-btn-yes,.confirm-btn-no{padding:10px 30px;border:none;border-radius:4px;cursor:pointer;font-size:16px}
.confirm-btn-yes{background-color:#28a745;color:#fff}
.confirm-btn-yes:hover{background-color:#218838}
.confirm-btn-no{background-color:#6c757d;color:#fff}
.confirm-btn-no:hover{background-color:#5a6268}






#subcontent-regla{background-color: rgb(35, 45, 50);position: relative;} 
.scroll-wrapper{width:100%;height:auto;max-height:200px;overflow:auto;border:0;position: relative;} /*quitar position relative*/
.contenedor{position:relative;width:100%;background-color:rgb(35, 45, 50);border-top:2px solid rgb(25, 25, 25);}/*quitar position relative*/
.detalles {
  width:auto;	
  height: auto;
  background-color: rgb(35, 45, 50); 
  display: none;               
  justify-content: center;     
  align-items: center;  
  padding:0;       
  gap: 10px;           
}
 

.detail-box {
  display:none;
  background-color: rgb(35, 45, 50);
  padding: 5px 5px;           
  border-radius: 4px;         
  color: white;      

  justify-content: center;       
  align-items: center;             
  text-align: center;  
  flex-direction: row;
  gap: 8px;
}
.delete-rectangle {
  display:none;  
  justify-content: center;       
  align-items: center;             
  text-align: center;  
}

.detail-description { 
  font-size:15px;
  background-color: rgb(95, 95, 95);
  padding: 5px 10px;           
  border-radius: 4px;         
  color: white;    
}

#dropdown_property {
  display: block; /* contenedor normal */
}

#dropdown_property select {
  display: flex;    /* el dropdown es un flex item (opcional si quieres flex interno) */
  width: 100%;      /* ocupa todo el ancho de su contenedor */
  padding: 4px 8px;
  font-size: 14px;
  border-radius: 4px;
  border: 1px solid #ccc;
  box-sizing: border-box; /* importante para incluir padding en el ancho */
  background-color: white;
}






#propiedades_regla {
    display: none;
    background-color: rgb(35, 45, 50);
    flex-wrap: wrap;
    /*gap: 10px;*/
    align-items: center;
    padding: 5px;/*quitar cero*/
    margin: 8px 0;	
}

#propiedades_regla p {
    color: white;
    margin: 0 10px;
    font-weight: bold;
}

 
/*border-radius: 5px;*/
/*
#propiedades_regla .button_property { 
    color: white;
    border: none; 
    padding: 5px 10px;
    cursor: pointer;
    font-size: 14px; 
}
*/

#propiedades_regla .button_property { 
    
    background-color: rgb(25, 25, 25);
    text-shadow: 1px 2px 4px rgba(0,0,0);
    color: white;
    border: 1px solid rgba(255,255,255,0.15);
    padding: 6px 12px;
    cursor: pointer;
    font-size: 14px;
    border-radius: 5px; 
    margin:2px 0;  
    transition: all 0.2s ease;
}

#propiedades_regla .button_property.simulado_activo { 

    background-color: rgb(124, 85, 230);

    border: 1px solid rgba(255,255,255,0.15);
    margin:2px 0; 

    transform: translateY(1px); /* se ve hundido, no elevado */
}




#propiedades_regla .button_property:hover {
    transform: translateY(-2px);
}
 


.linea{position:absolute;height:2px;background:black;pointer-events:none;opacity:.25}
.marcador{position:absolute;width:2px;background:black;transform:translateX(-50%);opacity:.95}
.label-medicion{position:absolute;font-size:15px;color:white;text-align:center;transform:translateX(-50%);background:rgb(35, 45, 50)}

 
/*
.rectangulo-caja{position:absolute;height:50px;background:rgb(0,166,104);transform:translateY(-50%);z-index:9;cursor:grab}
*/
 
.rectangulo-caja {
    position: absolute;
    height: 50px;
    /*background: linear-gradient(135deg, #9874ff 0%, #7c55e6 50%, #532ebd 100%);*/
    background: #7c55e6; 
    transform: translateY(-50%);
    z-index: 9;
    cursor: grab; 
    border-radius: 8px; 
/*
    box-shadow: 
        0 4px 12px rgba(124, 85, 230, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        inset 0 -2px 0 rgba(0, 0, 0, 0.15); 
 
    border: 1px solid rgba(255, 255, 255, 0.2);
*/
}

.rectangulo-caja:hover {
    background: linear-gradient(135deg, #a794ff 0%, #8b6aea 50%, #623dd5 100%);
    box-shadow: 
        0 6px 16px rgba(124, 85, 230, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.5),
        inset 0 -2px 0 rgba(0, 0, 0, 0.15);
    transform: translateY(-50%);
}

.rectangulo-caja:active {
    cursor: grabbing; 
    transform: translateY(-50%);
    box-shadow: 
        0 2px 8px rgba(124, 85, 230, 0.4),
        inset 0 1px 3px rgba(0, 0, 0, 0.2);
}
 




.rectangulo-caja.dragging{cursor:grabbing} 
 
.extremo-blanco {
    position: absolute;
    width: 12px;
    height: 50px;
    background: linear-gradient(135deg, #ffffff 0%, #e8e8e8 100%);
    top: 50%;
    transform: translateY(-50%);
    cursor: ew-resize;
    z-index: 11; 
    box-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
}

.extremo-blanco.izquierdo {
    left: -12px; 
    border-radius: 4px 0 0 4px; 
}

.extremo-blanco.derecho {
    right: -12px; 
    border-radius: 0 4px 4px 0; 
}

.extremo-blanco:hover {
    background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
    box-shadow: 
        0 3px 12px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
}


/* 
.boton-mas{position:absolute;width:24px;height:24px;background:rgb(49,255,176);color:black;border:none;border-radius:50%;font-size:16px;font-weight:bold;cursor:pointer;z-index:12;transform:translate(-50%,-50%)}
*/ 
 
.boton-mas {
    position: absolute;
    width: 24px;
    height: 24px;
    background: linear-gradient(135deg, #31ffb0 0%, #00e89a 100%);
    color: black;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    z-index: 12;
    right: -12px;   
    transform: translate(-50%, calc(-100% - 25px)); /* A√±ade 5px m√°s arriba */
    box-shadow: 
        0 3px 10px rgba(49, 255, 176, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.6),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2); 
    border: 2px solid rgba(255, 255, 255, 0.5);
}
.boton-mas:hover {
    background: linear-gradient(135deg, #4dffbd 0%, #1affaf 100%);
    box-shadow: 
        0 5px 15px rgba(49, 255, 176, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.7),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2);
    transform: translate(-50%, calc(-100% - 25px)) scale(1.1);
}
.boton-mas:active {
    transform: translate(-50%, calc(-100% - 25px)) scale(0.95);
}












 
@media (max-width: 600px) {
.rectangulo-caja{height:40px}
.extremo-blanco{height:40px}
}
 

@media (max-width: 450px) {

 
    
    .empty-block-container {
        padding-bottom: 30px;
    }

    .label-medicion{
       font-size:14px;
    }
}

</style>




<style>
 


 
*{margin:0;padding:0;box-sizing:border-box}body{font-family:Arial,sans-serif;background-color:rgb(50, 65, 69);min-height:100vh;display:flex;flex-direction:column}#stepPreview{display:none}

 
 
   

.tabs-container{display:flex;background-color:#141414;border:none;align-items:stretch}.tabs-add-button{flex:0 0 40px;background-color:rgb(25, 25, 25);text-shadow: 0 1px 2px rgba(0,0,0);color:#fff;border:none;font-size:25px;cursor:pointer;border-right:1px solid #333;display:flex;align-items:center;justify-content:center;height:40px}.tabs-add-button:hover{background-color:#444}.tabs-scroll-container{flex:1;display:flex;overflow-x:auto;overflow-y:hidden;white-space:nowrap}.tabs-scroll-container::-webkit-scrollbar{height:6px}.tabs-scroll-container::-webkit-scrollbar-thumb{background-color:#666;border-radius:3px}.tab{padding:10px 15px;background-color:rgb(25, 25, 25);color:#fff;cursor:pointer;border:none;border-right:1px solid #333;font-size:14px;white-space:nowrap;flex-shrink:0;transition:background-color .2s;width:auto}.tab:hover{background-color:#444}.tab.active{background-color:#7c55e6;text-shadow: 0 1px 2px rgba(0,0,0);}.tab-content{flex:1;padding:0px;display:none;align-items:center;justify-content:center;font-size:18px;color:#666}.tab-content.active{display:flex}

#new_project{font-size:12px;padding:0 15px;background-color:rgb(25,25,25);border:none;border-right:1px solid rgb(65,65,65);color:rgb(255,255,255);cursor:pointer;}
#new_project:hover{background-color:#444}

.modal-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);z-index:1000}.modal-content{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background-color:red;padding:20px;border-radius:8px;width:90%;max-width:500px; max-height:80vh;overflow-y:auto}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}.modal-close{background:0 0;border:none;font-size:24px;cursor:pointer;color:rgb(200,210,220);}.modal-close:hover{color:rgb(255,255,255);}.error-message{background-color:#f44;color:#fff;padding:10px;border-radius:4px;margin-bottom:15px;display:none;text-align:center}.files-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:20px}.file-item{aspect-ratio:1;border:2px dashed #ccc;display:flex;align-items:center;justify-content:center;cursor:pointer;background-color:#f9f9f9;border-radius:8px;position:relative;overflow:hidden}.file-item:hover{border-color:#007bff;background-color:#f0f8ff}.file-item.add-button{font-size:24px;color:#666}.file-preview{width:100%;height:100%;object-fit:cover}.file-name{position:absolute;bottom:0;left:0;right:0;background:rgba(0,0,0,.7);color:#fff;padding:2px 4px;font-size:10px;text-align:center}.file-name-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);z-index:1000}

.modal-content{
  background: rgba(25, 40, 60, 0.55);  
  padding: 20px;
  border-radius: 12px;  
  box-sizing: border-box; 
   color:white;

 
  backdrop-filter: blur(10px) saturate(140%);
  -webkit-backdrop-filter: blur(10px) saturate(140%);

   
  border: 1px solid rgba(255, 255, 255, 0.25);

   
  box-shadow:
    0 0 20px rgba(0, 0, 0, 0.45),
    inset 0 1px 2px rgba(255, 255, 255, 0.2);

   
  background-image: linear-gradient(
    rgba(255,255,255,0.1),
    rgba(0,0,0,0.2)
  );
}



.file-name-form{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;padding:20px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,.3);z-index:1001;width:90%;max-width:250px;box-sizing:border-box}.file-name-form h3{margin-bottom:10px;color:#333}.file-name-form input{width:100%;padding:8px;margin:10px 0;border:1px solid #ccc;border-radius:4px}.file-name-form button{padding:8px 16px;margin:5px;border:none;border-radius:4px;cursor:pointer}.btn-confirm{background-color:#28a745;color:#fff;}.btn-cancel{background-color:#6c757d;color:#fff;}.hidden{display:none!important}

#file-name-form {
  background: rgba(25, 40, 60, 0.55);  
  padding: 20px;
  border-radius: 12px;  
  box-sizing: border-box; 
   color:white;

 
  backdrop-filter: blur(10px) saturate(140%);
  -webkit-backdrop-filter: blur(10px) saturate(140%);

   
  border: 1px solid rgba(255, 255, 255, 0.25);

   
  box-shadow:
    0 0 20px rgba(0, 0, 0, 0.45),
    inset 0 1px 2px rgba(255, 255, 255, 0.2);

   
  background-image: linear-gradient(
    rgba(255,255,255,0.1),
    rgba(0,0,0,0.2)
  );
}



.plus-modal-overlay {
    position: fixed;
    inset: 0; /* top:0; right:0; bottom:0; left:0; */
    display: none;
    justify-content: center; /* centro horizontal */
    align-items: center;     /* centro vertical */
    z-index: 9999;
    background: rgba(0,0,0,0.5); /* opcional */
}


 
 
 


 
.general-main { 
    display: flex; 
    width: 100%; 
    height: calc(100vh - var(--empty-block-height, 40vh)); 
    min-height:320px;
    max-height:520px;
    background-color: transparent; 
    transition: height 0.3s ease;
    overflow: hidden;
}    

 


.general-1{ 
    flex: 1;  
    display: flex; 
    justify-content: center; 
    align-items: center; 
    background-color: transparent;
    overflow: hidden;
    margin:20px 0; 
} 
 
.main-container { 
    display: flex; 
    flex-direction: column; 
    justify-content: flex-start; 
    align-items: center; 
    width: 90%; 
    aspect-ratio: 512/320;/*height: 100%;si pongo esto se alarga mucho si el ratio del window es 9:16*/
    max-height: 100%;
    background-color: transparent; 
} 

.video-block {
    position: relative;
    width: 100%;
    flex: 1;
    min-height: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: visible; 
}

/*wrapper-multimedia #stepVideoTagContent*/
.wrapper-multimedia { 
    display: flex;
    flex-direction: column;
    align-items: stretch;
    height: 100%;
    max-height: 100%;
    max-width: 100%; 
    aspect-ratio: 512/320;/*400/257*/
    background-color: transparent;   
} 
 
    

 

 

.video-content {
    flex: 1;
    min-height: 0;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.video-block video {
    width: 100%;
    height: 100%;
    aspect-ratio: 16 / 9;
    object-fit: contain;
    background-color: transparent;/*red*/
    border-radius: 15px 15px 0 0;
}


/*
#video_preview { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; aspect-ratio: 16 / 9; background-color:yellow; }
*/

#video_preview {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    aspect-ratio: 16 / 9;
    background-color: transparent;
    position: relative;  
    overflow: hidden;
}

#liveCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.video-block canvas {
    width: 100%;
    height: 100%;
    object-fit: contain;
    background-color: black;
    border-radius: 6px 6px 0 0;
}
 
 
 
 

.buttons-block {
    display: flex;
    width: 100%;
    margin: 0;                 
    padding: 0;                
    border: 0;
    gap: 2px;                     
    flex-shrink: 0;
    aspect-ratio: 32/2;/*25/2*/
    align-items: stretch;
    min-height: 0;   
    background-color: rgb(25,25,25);
}

 
.buttons-block button {
    flex: 1;
    border: 0;
    min-height: 0;
    margin: 0;
    line-height: normal;
    font-size: 1.2rem; 
    background-color: rgb(196, 205, 208);
    color: rgb(0,0,0);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  
    position: relative;
    overflow: hidden;
 
    letter-spacing: 0.3px;
    transition: all 0.25s ease;
}

 
 
.buttons-block button::before {
    content: "";
    position: absolute;
    inset: 0;
    font-weight: bold;
/*	
    background: linear-gradient(
        to bottom,
        rgba(0,0,0,0.10) 0%,    
        rgba(0,0,0,0.2) 50%,   
        rgba(0,0,0,0.10) 100%    
    );
*/
    background: linear-gradient(
        to bottom,
        rgb(196, 205, 208,0.1) 0%,      /* extremo superior: base */
        rgb(220, 230, 235,0.2) 50%,     /* centro: m√°s claro */
        rgb(196, 205, 208,0.1) 100%     /* extremo inferior: base */
    );

    pointer-events: none;
} 



 

.buttons-block button:hover {
    transform: translateY(-2px);
}
 








 

.buttons-block button:first-child {
    border-radius: 0 0 0 7px;
}

.buttons-block button:last-child {
    border-radius: 0 0 7px 0;
}
 
 
 










.empty-block-container {
    display: flex;
    flex-direction: column;
    justify-content: center;  
    align-items: center;      
    height: var(--empty-block-height, 40vh);  
    min-height: 150px;        
}

.empty-block {
    width: 100%;
    max-height: 100%;       
    height: auto;           
    display: none;
    flex-direction: column;
background-color: rgb(35, 45, 50);
}


 


.general-2 { flex: 1; display: flex; justify-content: center; align-items: center; background-color: transparent} 

.second-main-container { width: 90%; height: 90%; background-color: transparent; border-radius: 8px; display: flex; justify-content: center; align-items: center;padding:0 0px; }
 
.empty-block-container { width: 100%; height: var(--empty-block-height, 40vh); background-color: transparent; display: flex; flex-direction: column; transition: height 0.3s ease; justify-content: center; align-items: center; }

.empty-block-container {
    display: flex;
    flex-direction: column;
    justify-content: center;  
    align-items: center;  
    height: var(--empty-block-height, 40vh);
}

#botones-alineados {
  width: 100%;
  overflow-x: hidden;
  text-align: center; /* centra el grupo interno */
}

#grupo-botones {
  display: inline-flex;  /* inline-flex permite centrado con text-align */
  white-space: nowrap;
}

/*
#grupo-botones button {
  flex-shrink: 0;
  height: 40px;
  min-width:70px;
  font-size:14px; 
  text-align: center;
  white-space: normal;
  word-break: break-word;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  border: 1px solid rgb(25,25,25);
  border-radius: 8px;
  color:white;
  background-color: #7c55e6;
  cursor: pointer;
  margin:5px 0;
  line-height: 1;
}
*/

#grupo-botones button {
  flex-shrink: 0;
  height: 40px;
  min-width: 80px; 
  font-size: 14px; 
text-shadow: 1px 2px 4px rgba(0,0,0); 
  text-align: center;
  white-space: normal;
  word-break: break-word;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px 8px;
  border: 1px solid rgba(0, 0, 0,0.5);
  border-radius: 5px;
  color: white;
  background-color: linear-gradient(135deg, #8b6ce8 0%, #6a4bc9 100%);
  cursor: pointer;
  margin: 5px 0px; 
  line-height: 1; 
  transition: all 0.3s ease;
  font-weight: 500;
}

#grupo-botones button:hover {
  background-color: linear-gradient(135deg, #9d7ef5 0%, #7a5bd6 100%); 
  transform: translateY(-4px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}
 









.custom-dropdown {
    position: relative;
    width: 100%; ¬¥ 
    margin-top: 15px;	
    margin-bottom: 5px;
    cursor: pointer;
    color:rgb(0,0,0);
}

.dropdown-selected {
    padding: 4px;
    background: #eee;
    border: 1px solid #ccc;
    border-radius: 4px;
}

.dropdown-options {
    position: absolute;
    bottom: 100%;        /* üëà hace que se abra hacia ARRIBA */
    left: 0;
    width: 70%;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    display: none;       /* oculto por defecto */
    list-style: none;
    padding: 0;
    margin: 0 0 5px 0;   /* un peque√±o espacio hacia arriba */
    z-index: 999;
}

.dropdown-options li {
    padding: 4px;
    cursor: pointer;
}

.dropdown-options li:hover {
    background: #eee;
}

 


 

#modal_overlay_dinamico {
  position: fixed;
  inset: 0;
  background: rgba(0, 20, 40, 0.55); /* m√°s profundo y elegante */
  display: none;
  align-items: center;
  justify-content: center;
  padding: 10px;
  overflow: auto;
  box-sizing: border-box;

  /* efecto suavizado */
  backdrop-filter: blur(6px); 
}

#modal_box_dinamico { 
  background: rgba(25, 40, 60, 0.55); /* vidrio oscuro */
  padding: 20px;
  border-radius: 12px;
  display: inline-block;
  max-width: 90%;
  box-sizing: border-box; 
   color:white;

  /* efectos Aero */
  backdrop-filter: blur(10px) saturate(140%);
  -webkit-backdrop-filter: blur(10px) saturate(140%);

  /* borde brillante suave */
  border: 1px solid rgba(255, 255, 255, 0.25);

  /* iluminaci√≥n interna + sombra externa */
  box-shadow:
    0 0 20px rgba(0, 0, 0, 0.45),
    inset 0 1px 2px rgba(255, 255, 255, 0.2);

  /* brillo superior muy leve, t√≠pico Aero */
  background-image: linear-gradient(
    rgba(255,255,255,0.1),
    rgba(0,0,0,0.2)
  );
}









.dropdown_selector option {
  background: rgba(20, 35, 55, 0.85);
  color: #e8f4ff;
  padding: 10px;
  font-size: 14px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

/* Profundidad al abrir el men√∫ */
.dropdown_selector:focus option {
  background: rgba(22, 40, 60, 0.9);
}

/* Efecto de iluminaci√≥n al pasar el cursor */
.dropdown_selector option:hover {
  background: rgba(80, 140, 200, 0.85);
  color: white;
}

/* Opci√≥n seleccionada en el men√∫ */
.dropdown_selector option:checked {
  background: rgba(120, 180, 255, 0.85);
  color: #0b1a2f;
  font-weight: bold;
}






#general-0 {
    display: flex;
    flex-direction: column;
    align-items: center;          /* centrar horizontalmente */
    justify-content: center;      /* centrar verticalmente */
    margin: 20px 40px;
    height: auto;
    width: max-content;
    gap: 10px;
    user-select: none;            /* evitar selecci√≥n de texto */
}

.seccion-cuadrada {
    width: 50px;
    height: 50px;
    background-color: rgb(196, 205, 208);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    color: white;
    /*border: 1px solid rgb(25, 25, 25);*/
    border-radius: 5px;
    position: relative;           /* necesario para el tooltip */
    cursor: pointer; 
    box-shadow:
    0 0 0 1px rgba(255, 255, 255, 0.6),
    0 0 12px 2px rgba(255, 255, 255, 0.4); 
 
}
 
 
.tooltip {
    position: absolute;
    left: 100%;                   /* a la derecha del cuadrado */
    top: 50%;
    transform: translateY(-50%);
    background-color: white;
    color: black;
    padding: 5px;
    margin-left: 10px;             /* separaci√≥n del cuadrado */
    white-space: nowrap;           /* evitar que se corte el texto */
    display: none;                /* se muestra al hover */
    font-size: 14px;
    border-radius: 3px;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
    z-index:4;	
}

 
 

  
@media (max-width: 1000px) {

    body{background-color:rgb(35, 45, 50)}

    #general-header{display:block} 

    .plus-modal-header {  
    	display:flex;  
    }


    #general-0 { 
    	display:none; 
    }
	
    .general-main {
        flex-direction: row; /*column*/         
        height: auto;   
	min-height:auto;              
    }
 
    .general-1{   
        margin: 50px 0;
        padding: 0;
        height: auto; 
    }   
    
    .general-2{
        display: none;
    }
 
    .main-container {
        width: 100%;
        max-width: 400px;  
        padding: 0;
        height: auto;  
    }
    
    .second-main-container {
        width: 100%;
        height: auto;
    }
    
    .video-block {
        height: auto;  
        flex: none; 
    }

    .video-block video { 
    	border-radius: 6px 6px 0 0;
    }
 
    .wrapper-multimedia { 
        height: auto;
        width: 100%;
        max-width: 100%;
        aspect-ratio: 512/320;/*400/257*/ 
    } 
    
    .video-content {
        aspect-ratio: 16 / 9;
    }
    
    .second-main-container.plus-modal-content {
        margin: 5px 0;	
	max-height: 100%;
    }

    .plus-modal-content { 
        max-width:400px;
	max-height: 1000px;
    }
 
    
 
    
    .plus-modal-title{
        font-size: 14px;
    }

    .plus-modal-close {
    	display:flex; 
    }
    .buttons-block button { 
    font-size: 15px;
    }	
    #grupo-botones button{
    	margin: 5px 0px;
    }
    #grupo-botones button:hover {
    	transform: none;
    }
    #propiedades_regla .button_property:hover{
	transform: none;
    }
    .buttons-block button:hover {
        transform: none;
    }
    .tab-button-active-settings,
    .tab-button-inactive-settings { 
    font-size: 14px; 
    }
}

 
@media (max-width: 540px){

    .plus-modal-content { 
    	height: calc(100vh - 240px); 
    }

    .general-1{   
        margin: 0;
        padding: 0;
        height: auto; 
    }  

    #general-0 { 
    	margin: auto 20px; 
    }

    .seccion-cuadrada {
    	width: 50px;
    	height: 50px;  
    }
} 

@media (max-width: 450px) {

/*pendiente de quitar o mantener*/
.main-container {  
    aspect-ratio: 16/9; 
} 
     
    .buttons-block {
        position: fixed; 
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 100;
        gap:0;
        aspect-ratio: auto;  
         
    }

 
.buttons-block button { 
    font-size:12px;   
    border: 1px solid rgba(255, 255, 255, 0.4);
    background-color:rgb(25,25,25); 
    color: rgb(255,255,255); 
    height: auto; 
    padding: 2px 8px;
    min-height: 30px;
}
.buttons-block button::before {
    font-weight: bold;
    content: "";
    position: absolute;
    inset: 0;
 
    background:  rgba(65,65,65);

    pointer-events: none;
    opacity: 0;  
}

.video-block video { 
    border-radius: 0;
}

    
    .wrapper-multimedia {
        aspect-ratio: 16 / 9; /* Solo el video, sin altura de botones */
    }
    
    .empty-block-container {
        padding-bottom: 30px;
    }

    #grupo-botones button { 
        height: 35px;
  	font-size:12px;   
    } 

    .detail-box { 
  	flex-direction: column; 
  } 

     
   


}

@media (max-width: 320px) {
    #grupo-botones button { 
        height: 35px;
  	font-size:11px;  
    }
}
 
#item-loader{
display:none;
}

#liveCanvas{
	background-color: transparent; 
} 
 

  
.overlay_regla {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;             /* ocupa lo mismo que el scroll-wrapper */
    height: 100%;
    pointer-events: none;    /* no bloquea el scroll */
    z-index: 2;             /* se muestra por encima */
}

 
#add-file-btn{
    font-size:40px;
}

#cancel_task{display:flex;align-items:center;gap:10px}
#cancel_task button{display:flex;color:#fff;font-size:16px;background-color:#004ad3;align-items:center;justify-content:center;border:none;margin:0;border-radius:4px;padding:8px 10px;cursor:pointer}
#cancel_task p{display:flex;color:rgb(255,255,255);font-size:16px;margin:2px;padding:0}

</style> 


</head>
<body>

<div id="general-header"> 
</div>
    
<div class="general-wrapper">

 

<div class="general-main">
<div id="general-0"></div>
  <div class="general-1">
    <div class="main-container"> 
        <div id="stepVideoTag" class="video-block">
            <div id="stepVideoTagContent" class="wrapper-multimedia">
                <div class="video-content">
                    <video id="my-video-2" controls>
                        <source src="https://raw.githubusercontent.com/lazypapertech/lazypapertech.github.io/main/design2/black_1280x720.mp4" type="video/mp4">
                        Tu navegador no soporta el elemento video.
                    </video>
                </div>
                <div class="buttons-block">
                    <button id="upload-btn" translate="no">Upload</button>
                    <button id="plus-btn" translate="no">Shortcuts</button> 
                    <button id="finish-btn" translate="no">Apply changes</button>
                </div>
            </div>
        </div>

        <div id="stepPreview" class="video-block">    
            <div id="stepPreviewContent" class="wrapper-multimedia">
                <div class="video-content">
                    <div id="video_preview">
                        <canvas id="liveCanvas"></canvas>
                        <p id="preview_description"></p>
                    </div> 
                </div> 
            </div>
        </div>
    </div>
  </div>
  <div class="general-2">
    <div class="second-main-container">  
    </div>
  </div>		
</div>

    <div class="empty-block-container">
	<div id="item-loader">
		<div class="tab-loader" style="margin-top: 70px; margin-bottom: 70px;">
		    <div class="donut"></div>
		    <p id="loader-text" style="color: #ffffff; text-align: center; margin-top: 20px; font-size: 18px;"> 
			Loading item...
		    </p>
		 </div>
	</div>

        <div class="empty-block"> 
            <div class="tabs-container" id="tabs-container">
		<button id="new_project">New<br>Project</button>


                <button class="tabs-add-button" id="tabs-add-button">+</button>
                <div class="tabs-scroll-container" id="tabs-scroll-container">
                </div>
            </div>
            <div id="tab-contents">

		<div id="subcontent-regla">
			<div class="propiedades_regla" id="propiedades_regla"> 
				<p id="nombre_regla"></p>
			</div>

 
 


			<div class="detalles" id="detalles">  
<div id="botones-alineados">
  <div id="grupo-botones">
     <button style="display:none"></button>
    <button style="display:none"></button>
    <button style="display:none"></button>
    <button style="display:none"></button>
    <button style="display:none"></button>
    <button style="display:none"></button>
    <button style="display:none"></button>
    <button style="display:none"></button>
    <button style="display:none"></button>
    <button style="display:none"></button>
  </div>
</div> 
<!--
<div id="botones-alineados" style="width:100%; border:1px solid #aaa;"></div>
 
				<div class="detail-box" id="start-container"> </div>
				<div class="detail-box" id="end-container"> </div>
				<div id="dropdown_property"></div> 
				<div class="delete-rectangle" id="delete-rectangle"> </div>
-->
			</div>

			<div class="scroll-wrapper">
				<div class="contenedor" id="contenedor"></div>   
			</div> 
			<div id="overlay_regla" class="overlay_regla">
					<div id="overlay_flecha" style="position:absolute; top:76px; left:31px; font-size:20px;color:white;">
        					‚ñº
    					</div>
					<!-- 
					<div style="
        					position:absolute;
        					top:92px;        
        					left:40px; 
        					width:2px;       
        					height:88px;    
        					background-color:#e23445;
    					">‚ö°</div>
					-->
<!-- 
					<div style="
    position: absolute;
    top: 120px;
    left: 32px;
    width: 29px;              
    height: 29px;             
    background-color: white;
    border-radius: 50%;       
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 16px;           
	
">
    ‚ö°
</div>
-->

					 
				</div>
		</div> 

            </div>
        </div>
    </div>

</div><!--wrapper-->

<div id="modal_overlay_dinamico">
  <div id="modal_box_dinamico"> 
  </div>
</div>


    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <p style="font-size:18px;font-weight:bold;">Upload files</p>
                <button class="modal-close" id="modal-close">&times;</button>
            </div>
             
            <div class="files-grid" id="files-grid">
                <div class="file-item add-button" id="add-file-btn">+</div>
            </div>
        </div>
    </div>


 
<!-- 
<div class="plus-modal-overlay" id="plus-modal-overlay">
 
  <div class="plus-modal-content">
    <div class="plus-modal-header">
      <p class="plus-modal-title">Settings</p>
      <button class="plus-modal-close" id="plus-modal-close">&times;</button>
    </div>

    <div class="tabs-menu-container-settings">
      <button class="tab-button-active-settings" data-tab="general-tab-content-settings">General (panel editable)</button>
      <button class="tab-button-inactive-settings" data-tab="advanced-tab-content-settings">Advanced (console)</button>
    </div>

    <div class="script-panel-container" id="script-panel-container">

      <div class="tab-content-general-settings active" id="general-tab-content-settings">

        <div class="script-panel-wrapper">

          <div class="script-panel-editor-area">
            <div class="script-panel-editor" id="script-editor" contenteditable="true"> nombre
            </div>
          </div>

          <div class="script-panel-menu">
            <button id="btn-run-script">Run script</button>
            <button id="btn-create-button">Create button</button>
          </div>

        </div>

         
        <div class="script-create-modal" id="script-create-modal">
          <div class="script-create-modal-content">

            <button id="close-create-modal">√ó</button>

            <select id="function-select"></select>
            <input type="text" id="button-name-input" placeholder="button name">
            <button id="confirm-create-button">crear boton</button>

          </div>
        </div>

      </div>

      <div class="tab-content-advanced-settings" id="advanced-tab-content-settings">
        <div class="script-panel-console" id="script-console"></div> 
      </div> 

    </div> 

  </div> 

</div>
-->
 




<div class="plus-modal-overlay" id="plus-modal-overlay">
  <div class="plus-modal-content">
    <div class="plus-modal-header">
      <p class="plus-modal-title">Advanced</p>
      <button class="plus-modal-close" id="plus-modal-close">&times;</button>
    </div>
    <div class="tabs-menu-container-settings">
      <button class="tab-button-active-settings" data-tab="general-tab-content-settings" translate="no">AI Shortcuts</button>
      <button class="tab-button-inactive-settings" data-tab="advanced-tab-content-settings" translate="no">Comments</button>
      <button class="tab-button-inactive-settings" data-tab="team-tab-content-settings" translate="no">Teams</button>
    </div>
    <div id="different_tabs"></div>  
  </div> 
</div>
 


 




 
    <div class="file-name-overlay" id="file-name-overlay"></div>
    <div class="file-name-form" id="file-name-form">
        <p style="font-size:18px;font-weight:bold;margin:10px 5px 10px 5px;">New item<p>
        <div class="error-message" id="error-message"></div>

	<input type="text" id="custom-name-input" placeholder="Item name..." maxlength="15">

	<div class="custom-dropdown" id="custom-dropdown" style="margin-bottom: 20px;">
           <div class="dropdown-selected" id="dropdown-selected">Select option</div>
    		<ul class="dropdown-options" id="dropdown-options">
        		<li data-value="image">image</li>
        		<li data-value="video">video</li>
        		<li data-value="audio">audio</li>
        		<li data-value="text">text</li>
    		</ul>
	</div>

         
        <div style="margin-bottom: 10px;">
            <button class="btn-confirm" id="confirm-name">Confirm</button>
            <button class="btn-cancel" id="cancel-name">Cancel</button>
        </div>
    </div>
 

<!-- Modal de error (fondo rojo) -->
<div class="error-modal-overlay" id="error-modal-overlay">
    <div class="error-modal-content">
        <div class="error-modal-header">
            <button class="error-modal-close" id="error-modal-close">&times;</button>
        </div>
        <p class="error-modal-message" id="error-modal-message"></p>
    </div>
</div>

<!-- Modal de confirmaci√≥n -->
<div class="confirm-modal-overlay" id="confirm-modal-overlay">
    <div class="confirm-modal-content">
        <div class="confirm-modal-header">
            <h3>Confirmar</h3>
            <button class="confirm-modal-close" id="confirm-modal-close">&times;</button>
        </div>
        <p class="confirm-modal-message">¬øRealmente quieres finalizar?</p>
        <div class="confirm-modal-buttons">
            <button class="confirm-btn-yes" id="confirm-btn-yes">Yes</button>
            <button class="confirm-btn-no" id="confirm-btn-no">No</button>
        </div>
    </div>
</div>
 
    <input type="file" id="file-input" accept="image/*,video/*,audio/*" multiple style="display: none;">


<script>

function generateRandomUserId() {
    const digits = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let userId = "";
    for (let i = 0; i < 10; i++) {
      const randomIndex = Math.floor(Math.random() * digits.length);
      userId += digits[randomIndex];
    }
    return userId;
}

let userId = localStorage.getItem("useridManycaptions");
//userId = "0123456789";
  
  if (!userId) {
    userId = generateRandomUserId();
    localStorage.setItem("useridManycaptions", userId);
  }
 
let current_scroll_x = 0;
let current_filetype="scene";
let current_filename;
let selected_rect;
let current_box_options = [];
 
let box_options = ["Delete_box"];

let current_timeline = [[],[],[],[]];
const initial_configuration = {"properties_with_keyframes":["scale","rotation","opacity","position", "camera_position","camera_zoom"],
				"properties_with_predefined_values":{"item_reveal":["show","hide","off"],"background_remove":["off","on"]}};
 
  




//quitar
 


function adaptPlusSection() {
  const plusBtn = document.getElementById('plus-btn');
  const plusModalContent = document.querySelector('.plus-modal-content');
  const secondMainContainer = document.querySelector('.second-main-container');
  const plusModalOverlay = document.getElementById('plus-modal-overlay');

  if (window.innerWidth > 1000) {
    // --- MODO ESCRITORIO ---
    plusBtn.style.display = 'none';
    plusModalOverlay.style.display = 'none'; // cerrar modal si estaba abierto

    // Verifica si ya no est√° insertado
    if (!secondMainContainer.querySelector('.plus-modal-content')) {
      // Mueve el contenido del modal al panel derecho
      secondMainContainer.innerHTML = ''; // limpia
      secondMainContainer.appendChild(plusModalContent);
 
      plusModalContent.style.display = 'flex';
      plusModalContent.style.flexDirection = 'column';
      plusModalContent.style.width = '100%';
      plusModalContent.style.height = '100%';
/*
      plusModalContent.style.borderRadius = '0';
      plusModalContent.style.boxShadow = 'none';
      plusModalContent.style.position = 'relative';
      plusModalContent.style.top = '0';
      plusModalContent.style.left = '0';
      plusModalContent.style.transform = 'none';
      plusModalContent.style.overflowY = 'auto';
      plusModalContent.style.borderRadius = "15px"; 
*/
      plusModalContent.style.boxShadow = '0 0 0 1px rgba(20, 20, 20, 0.6), 0 0 20px 4px rgba(0, 0, 0, 0.5)';
    }
  } else {
    // --- MODO MOBILE ---
    plusBtn.style.display = 'block';

    // Si el contenido est√° dentro del panel derecho, lo devolvemos al modal
    const modalInner = document.querySelector('.plus-modal-overlay');
    if (!modalInner.querySelector('.plus-modal-content')) {
      modalInner.appendChild(plusModalContent);
      plusModalContent.style = 'flex'; // restablece estilos 
       
	
    }
  }
}
 
  
window.addEventListener('resize', adaptPlusSection);
window.addEventListener('load', adaptPlusSection);
</script>

<script>

let websocketClient;
let filenames_llenos = 0;
let textnames_llenos = 0;
let valores_predefinidos = [1];
let current_item = "scene";
let current_property_id = "";

// AGREGAR estas constantes al inicio con las dem√°s
const errorModalOverlay = document.getElementById('error-modal-overlay');
const errorModalClose = document.getElementById('error-modal-close');
const errorModalMessage = document.getElementById('error-modal-message');
const confirmModalOverlay = document.getElementById('confirm-modal-overlay');
const confirmModalClose = document.getElementById('confirm-modal-close');
const confirmBtnYes = document.getElementById('confirm-btn-yes');
const confirmBtnNo = document.getElementById('confirm-btn-no');

// AGREGAR funci√≥n para mostrar modal de error
function showErrorModal(message) {
    errorModalMessage.textContent = message;
    errorModalOverlay.style.display = 'block';
}

// AGREGAR funci√≥n check_conditions
function check_conditions() {
    // Verificar si se ha subido al menos un archivo
    if (uniqueFiles.length === 0 && textnames_llenos==0) {
        showErrorModal('No multimedia files have been uploaded yet');
        return false;
    }
    
    // Verificar si se ha creado al menos un tab
    if (customNames.length <= 1) {
        showErrorModal('No tabs have been created yet. Press "+" to create one.');
        return false;
    }
    
    // Verificar si valores_predefinidos est√° vac√≠a
    if (filenames_llenos==0 && textnames_llenos==0) {//valores_predefinidos.length === 0
	//La lista "valores_predefinidos" esta vacia
        showErrorModal('"filename" property has no keyframe value. Assign it a value.');
        return false;
    }
    
    return true;
}

// AGREGAR eventos para cerrar modal de error
errorModalClose.addEventListener('click', () => {
    errorModalOverlay.style.display = 'none';
});

errorModalOverlay.addEventListener('click', (e) => {
    if (e.target === errorModalOverlay) {
        errorModalOverlay.style.display = 'none';
    }
});

// AGREGAR eventos para modal de confirmaci√≥n
confirmModalClose.addEventListener('click', () => {
    confirmModalOverlay.style.display = 'none';
});

confirmModalOverlay.addEventListener('click', (e) => {
    if (e.target === confirmModalOverlay) {
        confirmModalOverlay.style.display = 'none';
    }
});

confirmBtnNo.addEventListener('click', () => {
    confirmModalOverlay.style.display = 'none';
});

confirmBtnYes.addEventListener('click', () => {
    confirmModalOverlay.style.display = 'none';
    // Aqu√≠ se ejecutan las acciones del finish
    show_stepPreview();
    console.log('Acci√≥n realizada: Bot√≥n FINISH presionado');
    console.log('Estado actual de la aplicaci√≥n:', {
        archivosSubidos: uploadedFiles.length
    });
    equilibrar_rectangulos();
    const items_with_audio = extraerListasComoString(item_types, ["video","audio"], "/separator/");	
    console.log("items_with_audio: ",items_with_audio);
    const json_data = {"service":"update_video","itemName":current_timeline[3],"property":current_timeline[2],"params":"empty","items_with_audio":items_with_audio,"extra0":"","extra":""}; 
    websocketClient.send(JSON.stringify(json_data));
    crear_loading_tab(); 
    finalizar(); 
});


function ocultarPendientesYErrores() {
  const ids = ["error_subidas_pendientes", "pendientes_de_subir"];

  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.style.display = "none";
    }
  });
}


 

function request_render(){
    closeModalDinamico();
    // Aqu√≠ se ejecutan las acciones del finish
    show_stepPreview();
    console.log('Acci√≥n realizada: Bot√≥n FINISH presionado');
    console.log('Estado actual de la aplicaci√≥n:', {
        archivosSubidos: uploadedFiles.length
    });
    equilibrar_rectangulos();
    const items_with_audio = extraerListasComoString(item_types, ["video","audio"], "/separator/");	
    console.log("items_with_audio: ",items_with_audio);
    const json_data = {"service":"update_video","itemName":current_timeline[3],"property":current_timeline[2],"params":"empty","items_with_audio":items_with_audio,"extra0":"","extra":""}; 
    websocketClient.send(JSON.stringify(json_data));
    crear_loading_tab(); 
    finalizar();  
}

function renderPendientes(diccionario) {
  const ul = document.getElementById("pendientes_de_subir");
  if (!ul){return;}	
  ul.style.display="block";
  // opcional: limpiar antes
  ul.innerHTML = "";

  if (Object.keys(progress_visible_names).length == uploaded_names.length){
	ocultarPendientesYErrores();
  }		

  Object.keys(diccionario).forEach(key => {
    const value = diccionario[key]; // siempre string
    if (key!=value){	 
	console.log("key:",key,", value:",value);

    	const li = document.createElement("li");
    	li.textContent = value;
    	li.style.padding = "6px 4px";
    	li.style.borderBottom = "1px solid rgba(255,255,255,0.15)";

    	ul.appendChild(li);
    }	
  });
}

 
function extraerListasComoString(dic, claves, separator) {
  const resultado = [];

  for (const clave of claves) {
    if (Array.isArray(dic[clave])) {
      resultado.push(...dic[clave]);
    }
  }

  return resultado.join(separator);
}



        let uploadedFiles = {};
        let customNames = [];
        let file_types = {
            "image": [],
            "video": [],
            "audio": [],
	    "text": []	
        };

	//almacena el nombre de los items, no de los files
	let item_types = {
            "image": [],
            "video": [],
            "audio": []
        };

        const uploadBtn = document.getElementById('upload-btn');
        const finishBtn = document.getElementById('finish-btn');
        const plusBtn = document.getElementById('plus-btn');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalClose = document.getElementById('modal-close');
        const errorMessage = document.getElementById('error-message');
        const filesGrid = document.getElementById('files-grid');
        const addFileBtn = document.getElementById('add-file-btn');
        const fileInput = document.getElementById('file-input');
        const fileNameForm = document.getElementById('file-name-form');
        const fileNameOverlay = document.getElementById('file-name-overlay'); 
        const tabsScrollContainer = document.getElementById('tabs-scroll-container');
        const tabContents = document.getElementById('tab-contents');
        const tabsAddButton = document.getElementById('tabs-add-button');
        const plusModalOverlay = document.getElementById('plus-modal-overlay');
        const plusModalClose = document.getElementById('plus-modal-close'); 

	const dropdown_item = document.getElementById('custom-dropdown');
	const dropdownSelected_item = document.getElementById('dropdown-selected');
	const dropdownOptions_item = document.getElementById('dropdown-options');
	const customNameInput = document.getElementById('custom-name-input');
        const confirmNameBtn = document.getElementById('confirm-name');
        const cancelNameBtn = document.getElementById('cancel-name');

	const newProjectButton = document.getElementById('new_project'); 

	let selectedOption_item = null;

        let isCreatingTab = false;

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            setTimeout(() => {
                errorMessage.style.display = 'none';
            }, 3000);
        }

        function isNameTaken(name) {
            return customNames.includes(name);
        }

        function truncateTabName(name) {
            if (name.length <= 16) {
                return name;
            }
            return name.substring(0, 10) + name.substring(name.length - 6);
        }

function limpiarEspaciosYReemplazar(texto) { 
    let limpio = texto.trim().replace(/\s+/g, ' '); 
    limpio = limpio.replace(/ /g, '_'); 
    return limpio;
}
function limpiarEspacios(texto) { 
    let limpio = texto.trim().replace(/\s+/g, ' ');  
    return limpio;
}

        function createTab(name) { 

		name = limpiarEspaciosYReemplazar(name);
 
  		const tab = document.createElement('div');
                tab.className = 'tab';
                tab.dataset.tabName = name;
                tab.textContent = name;

                const content = document.createElement('div');
                content.className = 'tab-content';
                content.dataset.tabName = name;
                 
 
		let current_params = "empty"; 
		if (selectedOption_item){
			current_params = "filetype="+selectedOption_item;
		}
		const json_data = {"service":"change_item_view","itemName":name,"property":"empty","params":current_params,"file_type":selectedOption_item,"resolution":resolution_scene,"extra0":"0","extra":"0"}; 
 	
		 
		current_item = name; 
		console.log("MAL: ",name);

                tab.addEventListener('click', (e) => {
 
		    timestamp_and_duration=null;	

		    if (tab.classList.contains('active')) {
        		return;
    		    }

const modo = e.currentTarget.dataset.modo;
if (modo != 'delete_item') {
console.log("MAL: ",current_item);
const json_data_02 =  {"service":"save_item_data","itemName":current_item,"property":current_property_id,"params":"time="+current_scroll_x, "rectangulos":unica_regla.rectangulos,"extra":"change1"}; 
websocketClient.send(JSON.stringify(json_data_02)); 
}
 
	
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                    tab.classList.add('active');
                    content.classList.add('active');
		    current_item = name;
			 
 

                     
 	
		    websocketClient.send(JSON.stringify(json_data));
			crear_loading_tab(); 
			finalizar(); 
			
			show_vertical_line(); 
			 	
 	
                }); 
 
		if (isNameTaken(name)) {
			return;
		}else{
			customNames.push(name);
                	console.log('Nombre personalizado agregado:', name); 
			if (name!="scene"){
				current_property_id = "filename";//pendiente (no siempre sera asi)
			}
		} 


		 
 
		 

                      
		websocketClient.send(JSON.stringify(json_data));  
		crear_loading_tab();	
		finalizar();

                tabsScrollContainer.appendChild(tab);
                tabContents.appendChild(content);

                // Activar el nuevo tab autom√°ticamente al crearlo
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                content.classList.add('active');

 
 
	
 
        }

        uploadBtn.addEventListener('click', () => {
            console.log('Acci√≥n realizada: Bot√≥n UPLOAD presionado');
            modalOverlay.style.display = 'block';
        });

	 /*
        finishBtn.addEventListener('click', () => {
            show_stepPreview();
            console.log('Acci√≥n realizada: Bot√≥n FINISH presionado');
            console.log('Estado actual de la aplicaci√≥n:', {
                archivosSubidos: uploadedFiles.length
            });
        });*/

	/*
	finishBtn.addEventListener('click', () => {
    		if (check_conditions()) {
        		confirmModalOverlay.style.display = 'block';
    		}
	});*/
	finishBtn.addEventListener('click', () => {
		console.log("uploadedFiles: ",uniqueFiles.length);
		if (check_conditions()) { 
    			abrirModalDinamicoSimple(html_finish);
			renderPendientes(progress_visible_names);
		}
	});

        plusBtn.addEventListener('click', () => {
            console.log('Acci√≥n realizada: Bot√≥n + presionado');
	    //insertarPlusModalContent("plus-modal-overlay");	
            plusModalOverlay.style.display = 'flex';
        });

        tabsAddButton.addEventListener('click', () => {
            console.log('Acci√≥n realizada: Bot√≥n + de tabs presionado');
            isCreatingTab = true;
	    //abrirModalDinamicoSimple(html_create_item);
	    fileNameOverlay.style.display = 'block';
            fileNameForm.style.display = 'block';
	    customNameInput.focus();
        });

	newProjectButton.addEventListener('click', () => {
            console.log('Acci√≥n realizada: New Project'); 
		abrirModalDinamicoSimple(html_new_project);
        });

        plusModalClose.addEventListener('click', () => { 
            plusModalOverlay.style.display = 'none';  
        });
 
 

        modalClose.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
            errorMessage.style.display = 'none';
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.style.display = 'none';
                errorMessage.style.display = 'none';
            }
        });

        addFileBtn.addEventListener('click', () => {
            console.log('Acci√≥n realizada: Bot√≥n + presionado para agregar archivo');
            fileInput.click();
        });

	 

let filename_url={};

fileInput.addEventListener('change', (e) => {
  const files = e.target.files;
  if (!files || files.length === 0) return;

  for (const file of files) {
    const fileIdentifier = `${file.name}-${file.size}-${file.lastModified}`;
     
    // ‚ö†Ô∏è Evitar duplicados antes de crear el preview
    if (uniqueFiles.includes(fileIdentifier)) {
      console.log(`‚ö†Ô∏è Archivo duplicado, ya subido: ${file.name}`);
      continue;
    }

    console.log('Archivo seleccionado:', {
      nombre: file.name,
      tipo: file.type,
      tama√±o: file.size + ' bytes'
    });

    const fileItem = document.createElement('div');
    fileItem.className = 'file-item';
    fileItem.style.background = 'transparent';

    let fileType = '';
    if (file.type.startsWith('image/')) {
      const img = document.createElement('img');
      img.className = 'file-preview';
      img.src = URL.createObjectURL(file);
      fileItem.appendChild(img);
      fileType = 'image';
      console.log('Imagen agregada a la galer√≠a');
    } else if (file.type.startsWith('video/')) {
      const video = document.createElement('video');
      video.className = 'file-preview';
      video.src = URL.createObjectURL(file);
      video.muted = true;
      fileItem.appendChild(video);
      fileType = 'video';
      filename_url[file.name] = video.src;	
      console.log('Video agregado a la galer√≠a');
    } else if (file.type.startsWith('audio/')) {
      const audio = document.createElement('div');
      audio.textContent = 'üéµ';
      audio.style.fontSize = '40px';
      fileItem.appendChild(audio);
      fileType = 'audio';
      console.log('Audio agregado a la galer√≠a');
	const url_audio = URL.createObjectURL(file);
	filename_url[file.name] = url_audio;
    }

    const fileName = document.createElement('div');
    fileName.className = 'file-name';
    fileName.textContent = file.name;
    fileItem.appendChild(fileName);

    filesGrid.insertBefore(fileItem, addFileBtn);

    // Guarda el tipo de archivo
    if (fileType && file_types[fileType]) {
      file_types[fileType].push(file.name);
    }

    console.log('Archivo agregado:', file.name);
  }

  // üîÅ Ahora s√≠, maneja todos los archivos seleccionados en lote
  handleFileUpload(e);

  console.log('file_types:', file_types);

  // Limpia el input para permitir volver a seleccionar los mismos archivos luego
  fileInput.value = '';
});




dropdownSelected_item.addEventListener('click', () => {
    dropdownOptions_item.style.display =
        dropdownOptions_item.style.display === 'block' ? 'none' : 'block';
});

// Cuando se selecciona una opci√≥n
dropdownOptions_item.querySelectorAll('li').forEach(li_item => {
    li_item.addEventListener('click', () => {
        selectedOption_item = li_item.dataset.value;
        dropdownSelected_item.textContent = selectedOption_item;
        console.log("Opci√≥n seleccionada:", selectedOption_item); 

        dropdownOptions_item.style.display = 'none';
    });
});


confirmNameBtn.addEventListener('click', () => {

    if (!selectedOption_item) {
        showError('Selecciona una opci√≥n');
        return;
    }

    if (customNameInput.value.trim()) {
        const customName = customNameInput.value.trim();

        if (isNameTaken(customName)) {
            showError('Este nombre ya est√° en uso');
            return;
        }

        if (isCreatingTab) {
const json_data_02 =  {"service":"save_item_data","itemName":current_item,"property":current_property_id,"params":"time="+current_scroll_x, "rectangulos":unica_regla.rectangulos,"extra":"change2"}; 
websocketClient.send(JSON.stringify(json_data_02));
            createTab(customName);
            console.log('Tab creado con nombre:', customName); 
        }

        fileNameOverlay.style.display = 'none';
        fileNameForm.style.display = 'none';
        customNameInput.value = '';

        // Resetear dropdown
        selectedOption_item = null;
        dropdownSelected_item.textContent = "Select option";

        isCreatingTab = false;
    }
});


document.addEventListener('click', (event_item) => {
    // Si el clic NO ocurre dentro del contenedor del dropdown
    if (!dropdown_item.contains(event_item.target)) {
        dropdownOptions_item.style.display = 'none';
    }
});

 

        cancelNameBtn.addEventListener('click', () => {
            console.log('Acci√≥n realizada: Cancelar nombre personalizado');
	    fileNameOverlay.style.display = 'none';
            fileNameForm.style.display = 'none';
            customNameInput.value = '';
            isCreatingTab = false;
        });

        customNameInput.addEventListener('input', () => { 
            customNameInput.value = customNameInput.value.replace(/[^0-9a-zA-Z ]/g, '');
        });

	customNameInput.addEventListener('keydown', (e) => {
    		if (e.key === 'Enter') {
        		e.preventDefault();
        		confirmNameBtn.click();
    		}
	});

	fileNameOverlay.addEventListener('click', () => {
    		fileNameOverlay.style.display = 'none';
    		fileNameForm.style.display = 'none';
    		customNameInput.value = '';
    		isCreatingTab = false;
	});

 
 
         

         

         
 

 
        function hide_stepPreview() {
            let stepPreview = document.getElementById("stepPreview");
            if (stepPreview) {
                stepPreview.style.display = "none";
            }
        }

        function hide_videoTag() {
            let stepVideoTag = document.getElementById("stepVideoTag");
            if (stepVideoTag) {
                stepVideoTag.style.display = "none";
            }
        }

        function show_stepPreview() {
            hide_videoTag(); 
            let stepPreview = document.getElementById("stepPreview");
            if (stepPreview) {
                stepPreview.style.display = "flex";
            }
            resizeCanvas(); 
            start_loading();
        }

        function show_videoTag() {
            hide_stepPreview(); 
            hide_loading_tab();	 
            let stepVideoTag = document.getElementById("stepVideoTag");
            if (stepVideoTag) {
                stepVideoTag.style.display = "flex";
            } 
/*
	    unica_regla.selectedProperty = current_timeline[2];  
	    unica_regla.rectangulos = current_timeline[1];
	    rectangulos = current_timeline[1];
*/ 
            document.querySelector('.empty-block').style.display = "flex"; 	
	    create_buttons_properties(current_timeline[0]); 
    	    inicializar(unica_regla.rectangulos);//current_timeline[1]	unica_regla.rectangulos
	    activarBoton(current_timeline[2]);
        }

 

        console.log('Aplicaci√≥n inicializada correctamente');
        console.log('Breakpoints responsive configurados: 500px (75%) y 800px (50%)');
	// Crear tab por defecto al iniciar
	document.addEventListener('DOMContentLoaded', () => {
	    const defaultTabName = 'scene';
	    if (!customNames.includes(defaultTabName)) {
	        //customNames.push(defaultTabName); 
	        console.log('Tab por defecto creado:', defaultTabName);   
	    }
	});

 

   

 


</script>





















































 


<script>
 
let fondoRegla = null;
let lineaRegla = null;


// Datos de entrada
/*
let unica_regla = {
    selectedTab:"",	
    selectedProperty:"",	
    rectangulos: [
        {start: "00:00:00.0", end: "00:00:03.2", start_value: "text1", end_value: "text2","video_audio_value":"empty","bounce":"empty"},
        {start: "00:00:04.0", end: "00:00:06.4", start_value: "text3", end_value: "text4","video_audio_value":"empty","bounce":"empty"}
    ]
};
*/
let unica_regla = {
    selectedTab:"",	
    selectedProperty:"",	
    rectangulos: []
};

let resolution_scene = "1280x720";
const MINUTOS_TOTALES = 30;
const PASO_DELTA = 5;//0.2 segundos
const SEGMENTO_BASE = 20;
const CALIBRACION = 2;
const SEGMENTO = SEGMENTO_BASE * CALIBRACION;
const TOTAL_PUNTOS = MINUTOS_TOTALES*PASO_DELTA*60;
const ALTURA_REGLA = 80;
const PADDING = 40; 
const VALOR_SEGMENTO = 0.2;
let ANCHO_VENTANA_VIRTUAL = window.innerWidth;

let contenedor = document.getElementById('contenedor');
let scrollWrapper = document.querySelector('.scroll-wrapper');
let offsetVirtual = 0;
let marcadoresEnDOM = new Map();
let labelsEnDOM = new Map();
let todosLosMarcadores = [];
let todosLosLabels = [];
let rectangulos = [{"ancho": 80,"posicion":40,"start_value":"","end_value":"",video_audio_value:""}];

let arrastreActivo = false;
let rectanguloArrastrado = null;
let offsetInicialX = 0;
let posicionInicialRect = 0;

let redimensionActiva = false;
let rectanguloRedimensionado = null;
let ladoRedimension = '';
let posicionInicialMouse = 0;
let anchoInicial = 0;
let posicionInicialRectRedim = 0;
let rectanguloSeleccionado = null;

/* 
// 0.005s = 5ms 
const principal_video = document.getElementById('my-video-2');
  
const pxPorIntervalo = 2;
const intervalo = 0.01;  
let animationId; 
 
function actualizarScroll() {
    const currentTime = principal_video.currentTime;
    const pasos = Math.floor(currentTime / intervalo);
    scrollWrapper.scrollLeft = pasos * pxPorIntervalo;
}
function animarScroll() {
    const currentTime = principal_video.currentTime;
    const pasos = Math.floor(currentTime / intervalo);

    scrollWrapper.scrollLeft = pasos * pxPorIntervalo;

    animationId = requestAnimationFrame(animarScroll);
}

principal_video.addEventListener("play", () => {
    animationId = requestAnimationFrame(animarScroll);
});

principal_video.addEventListener("pause", () => {
    cancelAnimationFrame(animationId);
});

principal_video.addEventListener("ended", () => {
    cancelAnimationFrame(animationId);
});


// üéØ Cuando el usuario mueve el cursor estando pausado
principal_video.addEventListener("seeking", actualizarScroll);

// üéØ Cuando termina de mover el cursor
principal_video.addEventListener("seeked", actualizarScroll);
*/

 
/*
const principal_video = document.getElementById('my-video-2');
const pxPorIntervalo = 2;
const intervalo = 0.01;  
let animationId;
let videoControlaScroll = false; // Bandera invertida

// Funci√≥n para actualizar el scroll seg√∫n el video
function actualizarScroll() {
    const currentTime = principal_video.currentTime;
    const pasos = Math.floor(currentTime / intervalo);
    
    videoControlaScroll = true; // El video va a mover el scroll
    scrollWrapper.scrollLeft = pasos * pxPorIntervalo;
    
    // Resetear despu√©s de un momento
    setTimeout(() => {
        videoControlaScroll = false;
    }, 50);
}

// Animaci√≥n continua del scroll mientras el video reproduce
function animarScroll() {
    const currentTime = principal_video.currentTime;
    const pasos = Math.floor(currentTime / intervalo);
    
    videoControlaScroll = true;
    scrollWrapper.scrollLeft = pasos * pxPorIntervalo;
    
    animationId = requestAnimationFrame(animarScroll);
}

// Actualizar el video seg√∫n el scroll
function actualizarVideoPorScroll() {
    const scrollPos = scrollWrapper.scrollLeft;
    const pasos = Math.floor(scrollPos / pxPorIntervalo);
    const nuevoTiempo = pasos * intervalo;
    
    if (nuevoTiempo <= principal_video.duration) {
        principal_video.currentTime = nuevoTiempo;
    }
}

// Detectar cuando el usuario mueve el scroll
scrollWrapper.addEventListener('scroll', () => {
    // Si el video est√° controlando el scroll, ignorar
    if (videoControlaScroll) {
        return;
    }
    
    // El usuario movi√≥ el scroll
    // Pausar el video si est√° reproduci√©ndose
    if (!principal_video.paused) {
        principal_video.pause();
    }
    
    // Actualizar posici√≥n del video
    actualizarVideoPorScroll();
});

// Cuando el video empieza a reproducirse
principal_video.addEventListener("play", () => {
    videoControlaScroll = false;
    cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame(animarScroll);
});

// Cuando el video se pausa
principal_video.addEventListener("pause", () => {
    cancelAnimationFrame(animationId);
    videoControlaScroll = false;
});

// Cuando el video termina
principal_video.addEventListener("ended", () => {
    cancelAnimationFrame(animationId);
    videoControlaScroll = false;
});

// Cuando el usuario mueve el cursor del video estando pausado
principal_video.addEventListener("seeking", actualizarScroll);

// Cuando termina de mover el cursor del video
principal_video.addEventListener("seeked", actualizarScroll);
*/
 

 
const principal_video = document.getElementById('my-video-2');
const pxPorIntervalo = 2;
const intervalo = 0.01;

let animationId;

let videoControlaScroll = false;   // El video mueve el scroll
let usuarioControlaScroll = false; // El usuario mueve el scroll
let scrollTimeout;

// --- VIDEO -> SCROLL ---
function actualizarScroll() {
    if (usuarioControlaScroll) return; // <- no tocar scroll si el usuario est√° actuando

    const pasos = Math.floor(principal_video.currentTime / intervalo);
    videoControlaScroll = true;
    scrollWrapper.scrollLeft = pasos * pxPorIntervalo;
}

 
function animarScroll() {
    if (usuarioControlaScroll) return;

    const pasos = Math.floor(principal_video.currentTime / intervalo);
    videoControlaScroll = true;
    scrollWrapper.scrollLeft = pasos * pxPorIntervalo;

    animationId = requestAnimationFrame(animarScroll);
}
 

// --- SCROLL -> VIDEO ---
function actualizarVideoPorScroll() {
    const pasos = Math.floor(scrollWrapper.scrollLeft / pxPorIntervalo);
    const nuevoTiempo = pasos * intervalo;

    if (nuevoTiempo <= principal_video.duration) {
        principal_video.currentTime = nuevoTiempo;
    }
}

// --- EVENTOS ---

// Usuario mueve el scroll
scrollWrapper.addEventListener('scroll', () => {

    // Si el scroll fue causado por el video ‚Üí ignorar
    if (videoControlaScroll) {
        videoControlaScroll = false; // limpiar la bandera
        return;
    }

    // Desde aqu√≠ s√≠ es scroll del usuario
    usuarioControlaScroll = true;

    // Pausar solo si el usuario interviene
    if (!principal_video.paused) {
        principal_video.pause();
    }

    actualizarVideoPorScroll();

    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
        usuarioControlaScroll = false;
    }, 120);
});


// Play del video ‚Üí el video controla el scroll
principal_video.addEventListener("play", () => {
    usuarioControlaScroll = false;
    cancelAnimationFrame(animationId);
    animationId = requestAnimationFrame(animarScroll);
});

principal_video.addEventListener("pause", () => {
    cancelAnimationFrame(animationId);
    videoControlaScroll = false;
});

principal_video.addEventListener("ended", () => {
    cancelAnimationFrame(animationId);
    videoControlaScroll = false;
});

// seeking / seeked solo sincroniza si NO es el usuario
principal_video.addEventListener("seeking", actualizarScroll);
principal_video.addEventListener("seeked", actualizarScroll);
 

const desplazamiento_pausa = 30;
// --- DETECTOR DE TOUCH/TRACKPAD EN CONTENEDOR --- 
let touchStartX = 0;
let touchStartY = 0;
let mouseStartX = 0;

// Para touch (m√≥vil/tablet)
contenedor.addEventListener('touchstart', (e) => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}, { passive: true });

contenedor.addEventListener('touchmove', (e) => {
    const touchCurrentX = e.touches[0].clientX;
    const touchCurrentY = e.touches[0].clientY;
    const deltaX = Math.abs(touchCurrentX - touchStartX);
    const deltaY = Math.abs(touchCurrentY - touchStartY);
     
    if (deltaX > desplazamiento_pausa && deltaX > deltaY && !principal_video.paused) {
        usuarioControlaScroll = true;
        principal_video.pause();
    }
}, { passive: true });

// Para trackpad/mouse (escritorio)
contenedor.addEventListener('mousedown', (e) => {
    mouseStartX = e.clientX;
});

contenedor.addEventListener('mousemove', (e) => {
    // Solo si el bot√≥n est√° presionado (drag)
    if (e.buttons === 1) {
        const deltaX = Math.abs(e.clientX - mouseStartX);
        
        if (deltaX > desplazamiento_pausa && !principal_video.paused) {
            usuarioControlaScroll = true;
            principal_video.pause();
        }
    }
});

// Para wheel (rueda del mouse/trackpad)
contenedor.addEventListener('wheel', (e) => {
    // Detectar scroll horizontal
    if (Math.abs(e.deltaX) > desplazamiento_pausa && !principal_video.paused) {
        usuarioControlaScroll = true;
        principal_video.pause();
    }
}, { passive: true });
 











function formatearTiempoDecimal(totalSegundos) {
    /*const totalSeg = Number(totalSegundos);*/
    const totalSeg = Number(totalSegundos.toFixed(1));


    // Redondeo a d√©cimas
    let redondeado = Math.round(totalSeg * 10) / 10;

    // Evita valores como 60.0 segundos
    redondeado = Number(redondeado.toFixed(1));

    const horas = Math.floor(redondeado / 3600);
    const minutos = Math.floor((redondeado % 3600) / 60);
    const segundos = Math.floor(redondeado % 60);

    const decima = Math.round((redondeado * 10) % 10);

    let resultado =
        [horas.toString().padStart(2, '0'),
         minutos.toString().padStart(2, '0'),
         segundos.toString().padStart(2, '0')].join(':');

    if (decima > 0) resultado += '.' + decima;

    return resultado;
}
 

function sumarTiempo(timestamp, segundosFlotante, velocidad = 1) {
    // Parsear HH:MM:SS(.d)?
    const [h, m, s] = timestamp.split(':');

    // Normalizar segundos del timestamp a 1 decimal
    const segundosBase = Math.round(parseFloat(s) * 10) / 10;

    // Convertir timestamp completo a segundos
    let total = h * 3600 + m * 60 + segundosBase;

    // Aplicar velocidad ‚Üí duraci√≥n efectiva
    let duracionAjustada = segundosFlotante / velocidad;

    // Redondear duraci√≥n a 1 decimal
    duracionAjustada = Math.round(duracionAjustada * 10) / 10;

    // Sumar duraci√≥n ajustada
    total += duracionAjustada;

    // Redondeo general a 1 decimal para evitar basura
    total = Math.round(total * 10) / 10;

    // Descomponer
    const horas = Math.floor(total / 3600);
    const minutos = Math.floor((total % 3600) / 60);
    let segundos = total - horas * 3600 - minutos * 60;

    // Redondeo final
    segundos = Math.round(segundos * 10) / 10;

    // Caso borde: segundos = 60.0
    if (segundos >= 60) {
        segundos = 0;
        minutos++;
    }

    // Partes finales
    const segundosEnteros = Math.floor(segundos);
    const decima = Math.round((segundos - segundosEnteros) * 10);

    let result =
        String(horas).padStart(2, '0') + ':' +
        String(minutos).padStart(2, '0') + ':' +
        String(segundosEnteros).padStart(2, '0');

    if (decima > 0) result += '.' + decima;

    return result;
}




function timeToSeconds(timeStr) {
    const parts = timeStr.split(':');
    const horas = parseInt(parts[0]);
    const minutos = parseInt(parts[1]);
    const segundosPartes = parts[2].split('.');
    const segundos = parseInt(segundosPartes[0]);
    const decima = segundosPartes[1] ? parseInt(segundosPartes[1]) / 10 : 0;
    return horas * 3600 + minutos * 60 + segundos + decima;
}

function crearPseudoRegla_original() {
    const alturaPseudo = ALTURA_REGLA * 0.5;
    for (let i = 0; i <= TOTAL_PUNTOS; i++) {
        const x = PADDING + i * SEGMENTO;
        todosLosMarcadores.push({x: x, top: 0, height: alturaPseudo / 3});

        if (i % 5 === 0) {
            todosLosLabels.push({
                x: x,
                top: alturaPseudo / 3 + 2,
                texto: formatearTiempoDecimal(i / 5)
            });
        }
    }
}
 


function crearPseudoRegla() {
    const alturaPseudo = ALTURA_REGLA * 0.5;

    for (let i = 0; i <= TOTAL_PUNTOS; i++) {
        const x = PADDING + i * SEGMENTO;

        // Guardamos todos los marcadores
        todosLosMarcadores.push({ x: x, top: 0 });

        // Labels cada 5 puntos
        if (i % 5 === 0) {
            todosLosLabels.push({
                x: x,
                top: alturaPseudo / 3 - 4, // centro de la bolita
                texto: formatearTiempoDecimal(i / 5)
            });
        }
    }
}



function crearRegla() {
    const offsetY = ALTURA_REGLA * 0.5;
    const yRegla = offsetY + ALTURA_REGLA / 2;

    contenedor.style.width = `${ANCHO_VENTANA_VIRTUAL}px`;
    contenedor.style.height = `${ALTURA_REGLA * 1.5 + 10}px`;

    const fondo = document.createElement('div');
    fondo.style.position = 'absolute';
    fondo.style.top = `${offsetY}px`;
    fondo.style.left = '0';
    fondo.style.width = `${ANCHO_VENTANA_VIRTUAL}px`;
    fondo.style.height = `${ALTURA_REGLA}px`;
    fondo.style.background = "rgb(35, 45, 50)";
    fondo.style.borderTop = "2px solid rgb(27, 27, 27)";
    fondo.style.borderBottom = "none";
    fondo.style.borderLeft = "none";
    fondo.style.borderRight = "none";
    fondo.style.boxShadow = "inset 0 0 0 3px rgb(35, 45, 50)";
    fondo.style.zIndex = '-1';
    contenedor.appendChild(fondo);

    for (let i = 0; i <= TOTAL_PUNTOS; i++) {
        const x = PADDING + i * SEGMENTO;
        todosLosMarcadores.push({
            x: x,
            top: yRegla - ALTURA_REGLA / 8,
            height: ALTURA_REGLA / 4
        });
    }
/*
    //linea horizontal que aparecia en el medio de la regla
    const linea = document.createElement('div');
    linea.classList.add('linea');
    linea.style.top = `${yRegla}px`;
    linea.style.left = '0';
    linea.style.width = `${ANCHO_VENTANA_VIRTUAL}px`;
    contenedor.appendChild(linea);
*/



/*comentar*/
 
fondoRegla = document.createElement('div');
fondoRegla.style.position = 'absolute';
fondoRegla.style.top = `${offsetY}px`;
fondoRegla.style.left = '0';
fondoRegla.style.width = `${ANCHO_VENTANA_VIRTUAL}px`;
fondoRegla.style.height = `${ALTURA_REGLA}px`;
fondoRegla.style.background = "rgb(35, 45, 50)";
fondoRegla.style.borderTop = "2px solid rgb(27, 27, 27)";
fondoRegla.style.boxShadow = "inset 0 0 0 3px rgb(35, 45, 50)";
fondoRegla.style.zIndex = '-1';
contenedor.appendChild(fondoRegla);
/*
//linea horizontal que aparecia en el medio de la regla
lineaRegla = document.createElement('div');
lineaRegla.classList.add('linea');
lineaRegla.style.top = `${yRegla}px`;
lineaRegla.style.left = '0';
lineaRegla.style.width = `${ANCHO_VENTANA_VIRTUAL}px`;
contenedor.appendChild(lineaRegla);
*/
 
/*comentar*/

}




function crearDropdown() {
  const contenedor = document.getElementById("dropdown_property");
  contenedor.style.display = "flex";

  // Borra cualquier contenido previo
  contenedor.innerHTML = "";

  // Crear el dropdown
  const select = document.createElement("select");
  select.id = "mi_dropdown";

  select.innerHTML = `
    <option value="op1">Opci√≥n 1</option>
    <option value="op2">Opci√≥n 2</option>
  `;

  contenedor.appendChild(select);
}


 
function equilibrar_rectangulos() {
  // Asumimos que unica_regla es una variable global
  if (!unica_regla) return;

  unica_regla.rectangulos = unica_regla.rectangulos.filter(rect => {
    const startVal = rect.start_value?.trim() || "";
    const endVal = rect.end_value?.trim() || ""; 

    // Si uno est√° vac√≠o, se rellena con el otro
    if (!endVal && startVal) rect.end_value = startVal;
    if (!startVal && endVal) rect.start_value = endVal;

    return true; // mantener el rect√°ngulo en la lista
  });
}



function sincronizar_rectangulos_contiguos(indice) {
  const principal = unica_regla.rectangulos[indice]; 
  if (!principal) return;

            // üîπ Izquierda
  	    const izq = unica_regla.rectangulos[indice - 1]; 
  	    if (izq && izq.end === principal.start) {
    		izq.end_value = principal.start_value;
    		rectangulos[indice-1].end_value = principal.start_value;
		console.log("IZQUIERDA ‚úÖ NOOOOOOOOOOOOOOOO");
  	    }

            // üîπ Derecha
  	    const der = unica_regla.rectangulos[indice + 1];
  	    if (der && principal.end === der.start) { 
    		der.start_value = principal.end_value;
		rectangulos[indice+1].start_value = principal.end_value;
                console.log("‚úÖ Unica_regla.rectangulos: ",JSON.stringify(unica_regla.rectangulos));
  	    }
}




 
function moverOverlay(dx, dy) { 
  const overlay_flecha = document.getElementById('overlay_flecha');
  overlay_regla.style.top = '42px'; 
}
function resetOverlay() {
  const overlay_flecha = document.getElementById('overlay_flecha'); 
  overlay_regla.style.top = '0px'; 
}





function seleccionarRectangulo(rect) {

     

    if (selected_rect){
    	apply_rounded_corners(selected_rect); 
    }

    selected_rect = rect; 
    if (selected_rect){
    	remove_rounded_corners(selected_rect);
    }
    show_rect_extrems(rect);

    // Deseleccionar el anterior  
    if (rectanguloSeleccionado && rectanguloSeleccionado !== rect) { 
        rectanguloSeleccionado.style.background = '#7c55e6';//rgb(0,166,104) 
	rectanguloSeleccionado.style.boxShadow = `
    		0 4px 12px rgba(124, 85, 230, 0.4),
        	inset 0 1px 0 rgba(255, 255, 255, 0.4),
        	inset 0 -2px 0 rgba(0, 0, 0, 0.15)
	`; 
    } 
    if (rectanguloSeleccionado && rectanguloSeleccionado == rect){
	rectanguloSeleccionado.style.boxShadow = `
	    0 6px 16px rgba(0, 166, 104, 0.5),
            inset 0 1px 0 rgba(255, 255, 255, 0.5),
            inset 0 -2px 0 rgba(0, 0, 0, 0.15) 
	`; 
    }


	 
 

    document.getElementById('botones-alineados').style.display = "block";

    const detalles = document.getElementById('detalles'); 
    detalles.style.display = "flex";	
    
    // Seleccionar el nuevo
    rectanguloSeleccionado = rect;
     
    const indiceSeleccionado = parseInt(rectanguloSeleccionado.dataset.indice); 
        const rectSeleccionado = rectangulos[indiceSeleccionado]; 
	if (rectSeleccionado.start_value.includes("/%(bounce)%/")){
		rect.style.background = 'rgb(255, 249, 105)';//rgb(65,134,191)
		box_options=["Delete_box","bounce_parameters"];
	}else{
        	rect.style.background = '#02f57c';//#02f57c
		box_options = current_box_options;
	} 	
     
    //rect.style.background = 'yellow';

    const indice = parseInt(rect.dataset.indice);
    console.log(JSON.stringify(unica_regla.rectangulos[indice], null, 2));

    // === Mostrar detalles din√°micos ===
    const detalle = unica_regla.rectangulos[indice]; 
 
    generarBotones(box_options);
 
 
    const emptyBlockContainer = document.querySelector('.empty-block-container');
    const generalMain = document.querySelector('.general-main');

 
    if (window.innerWidth > 1000) {
    	const emptyHeight = emptyBlockContainer.offsetHeight;
    	generalMain.style.height = `calc(100vh - ${emptyHeight + 40}px)`;   
    } else {
    	generalMain.style.height = 'auto'; // deja que el media query haga su trabajo
    } 
 
    // Actualizar el bot√≥n "+"
    crearBotonMas();

    //get_interval_parameters();

moverOverlay(0, 20); 
}




 
 








function deseleccionarRectangulo() {
    if (selected_rect){
    	apply_rounded_corners(selected_rect); 
    }

    if (rectanguloSeleccionado) {   
	rectanguloSeleccionado.style.background = '#7c55e6';//rgb(0,166,104) 
	rectanguloSeleccionado.style.boxShadow = `
    		0 4px 12px rgba(124, 85, 230, 0.4),
        	inset 0 1px 0 rgba(255, 255, 255, 0.4),
        	inset 0 -2px 0 rgba(0, 0, 0, 0.15)
	`;  
        rectanguloSeleccionado = null;
    } 

 
    
    // Eliminar el bot√≥n "+"
    const botonAnterior = document.querySelector('.boton-mas');
    if (botonAnterior) botonAnterior.remove();
 
document.getElementById('botones-alineados').style.display = "none";

const emptyBlockContainer = document.querySelector('.empty-block-container');
const generalMain = document.querySelector('.general-main');

if (window.innerWidth > 1000) {
    const emptyHeight = emptyBlockContainer.offsetHeight;
    generalMain.style.height = `calc(100vh - ${emptyHeight}px)`;
} else {
    generalMain.style.height = 'auto'; // deja que el media query haga su trabajo
} 
	
}
 

function show_rect_extrems_0(rect) {
    // Primero ocultar todos los extremos de todos los rect√°ngulos
    rectangulos.forEach(r => {
        const extremos = r.elemento.querySelectorAll('.extremo-blanco');
        extremos.forEach(extremo => {
            extremo.style.display = 'none';
        });
    });
    
    // Mostrar solo los extremos del rect√°ngulo seleccionado
    const extremos = rect.querySelectorAll('.extremo-blanco');
    extremos.forEach(extremo => {
        extremo.style.display = 'block'; // o 'flex' dependiendo de tu CSS
    });
    remove_rounded_corners(selected_rect);
}

function show_rect_extrems_1(rect) {
    // Primero ocultar todos los extremos de todos los rect√°ngulos
    rectangulos.forEach(r => {
        const extremos = r.elemento.querySelectorAll('.extremo-blanco');
        extremos.forEach(extremo => {
            extremo.style.display = 'none';
        });
    });
    
    // Mostrar solo los extremos del rect√°ngulo seleccionado
    const extremos = rect.querySelectorAll('.extremo-blanco');
    extremos.forEach(extremo => {
        extremo.style.display = 'block'; // o 'flex' dependiendo de tu CSS
        extremo.style.zIndex = '2'; // ‚Üê A√±adir aqu√≠
    }); 
    remove_rounded_corners(selected_rect);
}

function show_rect_extrems(rect) {
    if (!rect) { 
        return;
    }
    if (current_filetype=="video" || current_filetype=="audio"){
        console.log("MAL REDIM: ",current_property_id);
        if (current_property_id=="filename"){
 	    return; 
        }
    }
    // Primero ocultar todos los extremos y resetear z-index de todos
    rectangulos.forEach(r => {
        r.elemento.style.zIndex = '1'; // z-index base
        const extremos = r.elemento.querySelectorAll('.extremo-blanco');
        extremos.forEach(extremo => {
            extremo.style.display = 'none';
        });
    });
    
    // Elevar el rect√°ngulo seleccionado
    rect.style.zIndex = '10'; // z-index alto para el seleccionado
    
    // Mostrar solo los extremos del rect√°ngulo seleccionado
    const extremos = rect.querySelectorAll('.extremo-blanco');
    if (extremos){
    	extremos.forEach(extremo => {
        	extremo.style.display = 'block';
        	extremo.style.zIndex = '2';
    	}); 
    } 
}

function hide_rect_extrems(rect) { 
    if (!rect) { 
        return;
    }
    const extremos = rect.querySelectorAll('.extremo-blanco');
    if (extremos){
    	extremos.forEach(extremo => {
		extremo.style.zIndex = '0';
        	extremo.style.display = 'none';
    	}); 
    } 
}

function apply_rounded_corners(rect) {
    rect.style.borderRadius = '8px';
}

function remove_rounded_corners(rect) {
    rect.style.borderRadius = '0';
}

function ocultarBotonMas() {
    const boton = document.querySelector('.boton-mas');
    if (boton) {
        boton.style.display = 'none';
    }
} 
function mostrarBotonMas() {
    const boton = document.querySelector('.boton-mas');
    if (boton) {
        boton.style.display = 'block';
    }
}

function opacidad_desplazamiento(rect) {
    apply_rounded_corners(rect);
    hide_rect_extrems(rect);
    ocultarBotonMas();	
    rect.style.opacity = '0.5';
}

function opacidad_reposo(rect) {
    remove_rounded_corners(rect);
    show_rect_extrems(rect);
    mostrarBotonMas();
    rect.style.opacity = '1';
}



const LONG_PRESS_TIME = 600;  
let touchTimer = null;
let touchStarted = 0;


function crearRectangulo(datos, indice) {
 
    const offsetY = ALTURA_REGLA * 0.5;
    const yRegla = offsetY + ALTURA_REGLA / 2;

    const segundosInicio = timeToSeconds(datos.start);
    const segundosFin = timeToSeconds(datos.end);
    const posicion = PADDING + (segundosInicio / VALOR_SEGMENTO) * SEGMENTO;
    const ancho = ((segundosFin - segundosInicio) / VALOR_SEGMENTO) * SEGMENTO;

    const rect = document.createElement('div');
    rect.classList.add('rectangulo-caja');
    rect.dataset.indice = indice; 
    rect.style.left = `${posicion - offsetVirtual}px`;
    rect.style.top = `${yRegla}px`;
    rect.style.width = `${ancho}px`; 
/* 
    rect.style.borderLeft = '1px solid rgb(196, 205, 208,0.6)';
    rect.style.borderRight = '1px solid rgb(196, 205, 208,0.6)';
    rect.style.borderTop = '1px solid rgb(196, 205, 208,0.9)';
    rect.style.borderBottom = '1px solid rgb(196, 205, 208,0.9)'; 
*/  
    rect.style.borderLeft = '1px solid rgb(35, 45, 50)';
    rect.style.borderRight = '1px solid rgb(35, 45, 50)';
 
    //rect.style.border = '1px solid rgb(196, 205, 208)';
    rect.dataset.xReal = posicion;
    rect.dataset.widthReal = ancho; 

    const extremoIzq = document.createElement('div');
    extremoIzq.classList.add('extremo-blanco', 'izquierdo');
    extremoIzq.style.display = 'none';
    rect.appendChild(extremoIzq);

    const extremoDer = document.createElement('div');
    extremoDer.classList.add('extremo-blanco', 'derecho');
    extremoDer.style.display = 'none';
    rect.appendChild(extremoDer);

    contenedor.appendChild(rect);

    rectangulos.push({
        elemento: rect,
        posicion: posicion,
        ancho: ancho,
        start_value: datos.start_value,
        end_value: datos.end_value,
	video_audio_value: datos.video_audio_value
    });

 
 

rect.addEventListener('mousedown', (e) => { 
e.preventDefault()

if (!e.target.classList.contains('extremo-blanco')) {
        	seleccionarRectangulo(rect); 
		show_rect_extrems(rect);
    	} 
    let arrastrando = false;

    function onMouseMove(ev) {
        if (!arrastrando) {
            arrastrando = true;
            console.log("Inicio arrastre"); 

            iniciarArrastre(e, rect);  // ‚Üê rect se pasa correctamente
        }

        //moverRectangulo(ev);//descomentar(pero funciona igual)
    }

    function onMouseUp() {
        arrastrando = false;
        finalizarArrastre(); 
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
    }

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
});



// Adem√°s, para m√≥viles, hacemos lo mismo que el mousedown pero con touchstart
rect.addEventListener('touchstart', (e) => {
    if (e.cancelable) {
        e.preventDefault();
    }

    if (!e.target.classList.contains('extremo-blanco')) {
        seleccionarRectangulo(rect); 
	show_rect_extrems(rect);
    } 

    let arrastrando = false;

    function onMove(ev) {
        const evento = ev.touches ? ev.touches[0] : ev;

        if (!arrastrando) {
            arrastrando = true;
            console.log("Inicio arrastre Touch"); 
            iniciarArrastreTouch(e, rect);   
        }
 
    }

    function onUp() {
        arrastrando = false;
        finalizarArrastreTouch(); 
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', onUp);
    }

    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    window.addEventListener('touchmove', onMove, { passive: false });
    window.addEventListener('touchend', onUp);
}, { passive: false });
 




rect.addEventListener('click', (e) => {
    if (!arrastreActivo && !redimensionActiva) {
        seleccionarRectangulo(rect); 
    }
});	 
 
if (current_filetype=="video" || current_filetype=="audio"){
console.log("MAL REDIM: ",current_property_id);
    if (current_property_id=="filename"){
 	return; 
    }
}
 
    extremoIzq.addEventListener('mousedown', (e) => iniciarRedimension(e, rect, 'izquierdo'));
    extremoDer.addEventListener('mousedown', (e) => iniciarRedimension(e, rect, 'derecho'));

    // M√≥viles
    extremoIzq.addEventListener('touchstart', (e) => iniciarRedimensionTouch(e, rect, 'izquierdo'));
    extremoDer.addEventListener('touchstart', (e) => iniciarRedimensionTouch(e, rect, 'derecho'));
 
 

}

 



function crear_bounce_rectangle() {
 
    const botonAnterior = document.querySelector('.boton-mas');
    if (botonAnterior) { 
	botonAnterior.remove();
    } 

    // Solo crear el bot√≥n si hay un rect√°ngulo seleccionado
    if (!rectanguloSeleccionado) return;
 

    const indiceSeleccionado = parseInt(rectanguloSeleccionado.dataset.indice);
    const rectSeleccionado = rectangulos[indiceSeleccionado];

    if (indiceSeleccionado<rectangulos.length-1){
    	const rectSeleccionadoAnterior = rectangulos[indiceSeleccionado+1];
    	if (rectSeleccionadoAnterior.start_value.includes("/%(bounce)%/")){
		//alert("There cannot be two bounce segments stuck together.");
		showErrorModal("There cannot be two bounce segments stuck together.");
		return;
	} 
    }	

 
 
    
    const posicionBoton = parseFloat(rectSeleccionado.posicion) + parseFloat(rectSeleccionado.ancho);
    const offsetY = ALTURA_REGLA * 0.5;
    const yRegla = offsetY + ALTURA_REGLA / 2;
 

  
  
    const segundosInicio = (posicionBoton - PADDING) / SEGMENTO * VALOR_SEGMENTO;
    const segundosFin = segundosInicio + VALOR_SEGMENTO;
    const nuevoRect = {
        start: formatearTiempoDecimal(segundosInicio),
        end: formatearTiempoDecimal(segundosFin),
        start_value: "3,0.4,/%(bounce)%/",
        end_value: "3,0.4,/%(bounce)%/",
	video_audio_value: ""
    };
    
    // Verificar si hay un rect√°ngulo pegado a la derecha
    if (indiceSeleccionado < rectangulos.length - 1) {
        const rectDerecha = rectangulos[indiceSeleccionado + 1];
        const finSeleccionado = parseFloat(rectSeleccionado.posicion) + parseFloat(rectSeleccionado.ancho);
        const inicioDerecha = parseFloat(rectDerecha.posicion);
        
        // Si est√°n pegados (sin hueco)
        if (Math.abs(finSeleccionado - inicioDerecha) < 1) {
            // Desplazar el de la derecha y todos los siguientes un SEGMENTO
            for (let i = indiceSeleccionado + 1; i < rectangulos.length; i++) {
                rectangulos[i].posicion = parseFloat(rectangulos[i].posicion) + SEGMENTO;
                rectangulos[i].elemento.dataset.xReal = rectangulos[i].posicion;
            }
            
            // Actualizar el estado global con las nuevas posiciones
            unica_regla.rectangulos = rectangulos.map(rect => {
                const segundosInicio = (parseFloat(rect.posicion) - PADDING) / SEGMENTO * VALOR_SEGMENTO;
                const segundosFin = segundosInicio + (parseFloat(rect.ancho) / SEGMENTO * VALOR_SEGMENTO);
	console.log("MAL segundosFin: ",segundosFin);
                return {
                    start: formatearTiempoDecimal(segundosInicio),
                    end: formatearTiempoDecimal(segundosFin),
                    start_value: rect.start_value,
                    end_value: rect.end_value,
		    video_audio_value: rect.video_audio_value
                };
            });
        }
    }
    
    // Insertar despu√©s del seleccionado
    unica_regla.rectangulos.splice(indiceSeleccionado + 1, 0, nuevoRect);
    
    // Recrear todos los rect√°ngulos
    rectangulos.forEach(r => r.elemento.remove());
    rectangulos = [];
    
    unica_regla.rectangulos.forEach((rectData, index) => {
        crearRectangulo(rectData, index);
	console.log("new rectangle");
	actualizarEstadoGlobal();
    });
    
    // Seleccionar el nuevo
    const nuevoElemento = rectangulos[indiceSeleccionado + 1].elemento;
    seleccionarRectangulo(nuevoElemento); 
    
    renderizarElementosVisibles();
  
 
}

function crearBotonMas() {
    const botonAnterior = document.querySelector('.boton-mas');
    if (botonAnterior) botonAnterior.remove();

    // Solo crear el bot√≥n si hay un rect√°ngulo seleccionado
    if (!rectanguloSeleccionado) return; 

    const indiceSeleccionado = parseInt(rectanguloSeleccionado.dataset.indice);
    const rectSeleccionado = rectangulos[indiceSeleccionado]; 
    
    const posicionBoton = parseFloat(rectSeleccionado.posicion) + parseFloat(rectSeleccionado.ancho);
    const offsetY = ALTURA_REGLA * 0.5;
    const yRegla = offsetY + ALTURA_REGLA / 2;

    const boton = document.createElement('button');
    boton.classList.add('boton-mas');
    boton.textContent = '+';
    boton.style.left = `${6+posicionBoton - offsetVirtual}px`;//6 es la mitad del ancho del extremo
    boton.style.top = `${yRegla}px`;
    boton.dataset.xReal = posicionBoton;

 
boton.addEventListener('click', (e) => {
    e.stopPropagation();
  
    const segundosInicio = (posicionBoton - PADDING) / SEGMENTO * VALOR_SEGMENTO;
    const segundosFin = segundosInicio + VALOR_SEGMENTO;//quitar el *2(genera rectangulo de 0.4,new rectangle)
    const nuevoRect = {
        start: formatearTiempoDecimal(segundosInicio),
        end: formatearTiempoDecimal(segundosFin),
        start_value: "",
        end_value: "",
	video_audio_value: ""
    };
    
    // Verificar si hay un rect√°ngulo pegado a la derecha
    if (indiceSeleccionado < rectangulos.length - 1) {
        const rectDerecha = rectangulos[indiceSeleccionado + 1];
        const finSeleccionado = parseFloat(rectSeleccionado.posicion) + parseFloat(rectSeleccionado.ancho);
        const inicioDerecha = parseFloat(rectDerecha.posicion);
        
        // Si est√°n pegados (sin hueco)
        if (Math.abs(finSeleccionado - inicioDerecha) < 1) {
            // Desplazar el de la derecha y todos los siguientes un SEGMENTO
            for (let i = indiceSeleccionado + 1; i < rectangulos.length; i++) {
                rectangulos[i].posicion = parseFloat(rectangulos[i].posicion) + SEGMENTO;
                rectangulos[i].elemento.dataset.xReal = rectangulos[i].posicion;
            }
            
            // Actualizar el estado global con las nuevas posiciones
            unica_regla.rectangulos = rectangulos.map(rect => {
                const segundosInicio = (parseFloat(rect.posicion) - PADDING) / SEGMENTO * VALOR_SEGMENTO; 
                const segundosFin = segundosInicio + (parseFloat(rect.ancho) / SEGMENTO * VALOR_SEGMENTO);
	console.log("MAL segundosFin: ",segundosFin);
                return {
                    start: formatearTiempoDecimal(segundosInicio),
                    end: formatearTiempoDecimal(segundosFin),
                    start_value: rect.start_value,
                    end_value: rect.end_value,
		    video_audio_value: rect.video_audio_value
                };
            });
        }
    }
    
    // Insertar despu√©s del seleccionado
    unica_regla.rectangulos.splice(indiceSeleccionado + 1, 0, nuevoRect);
    
    // Recrear todos los rect√°ngulos
    rectangulos.forEach(r => r.elemento.remove());
    rectangulos = [];
    
    unica_regla.rectangulos.forEach((rectData, index) => {
        crearRectangulo(rectData, index);
	console.log("new rectangle");
	actualizarEstadoGlobal();
    });
    
    // Seleccionar el nuevo
    const nuevoElemento = rectangulos[indiceSeleccionado + 1].elemento;
    seleccionarRectangulo(nuevoElemento); 
    
    renderizarElementosVisibles();
});
    contenedor.appendChild(boton);
}

 


function iniciarArrastreTouch(e, rect) {
    if (e.target.classList.contains('extremo-blanco')) return;

    opacidad_desplazamiento(rect);

    arrastreActivo = true;
    rectanguloArrastrado = rect;
    rectanguloArrastrado.classList.add('dragging');

    const rectContenedor = contenedor.getBoundingClientRect();

    // Detectamos si es touch o mouse
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;

    ultimoMouseXRelativo = clientX - rectContenedor.left + scrollWrapper.scrollLeft; 
    ultimaDireccion = 0;

    // Guardamos posici√≥n inicial del rect√°ngulo dentro del contenedor
    posicionInicialRect = parseFloat(rectanguloArrastrado.dataset.xReal);

    // Guardamos offset inicial del mouse/touch relativo al contenedor
    offsetInicialXContenedor = clientX - rectContenedor.left + scrollWrapper.scrollLeft;

    //e.preventDefault();
    if (e.touches && e.touches.length > 0) {
    	if (e.cancelable) e.preventDefault();
    } 	

    // En m√≥vil, moverRectangulo tambi√©n debe recibir el clientX correcto
/*
    document.addEventListener('mousemove', moverRectangulo, { passive: false });
    document.addEventListener('mouseup', finalizarArrastre);
*/
    document.addEventListener('touchmove', moverRectanguloTouch, { passive: false });
    document.addEventListener('touchend', finalizarArrastreTouch);
}


 
 


function moverRectanguloTouch_0(e) {
    if (!arrastreActivo || !rectanguloArrastrado) return;
    //e.preventDefault();
    if (e.touches && e.touches.length > 0) {
    	if (e.cancelable) e.preventDefault();
    } 	

    const rectContenedor = contenedor.getBoundingClientRect();
    const rectRectangulo = rectanguloArrastrado.getBoundingClientRect();
    const touch = e.touches[0];

    const mouseXRelativo =
        touch.clientX - rectContenedor.left + scrollWrapper.scrollLeft;

    // ------------------------------------------------
    // Direcci√≥n instant√°nea REAL del dedo
    // ------------------------------------------------
    if (ultimoMouseXRelativo !== null) {
        const deltaInstantaneo = mouseXRelativo - ultimoMouseXRelativo;
        if (deltaInstantaneo !== 0) ultimaDireccion = Math.sign(deltaInstantaneo);
    }
    ultimoMouseXRelativo = mouseXRelativo;

    // ------------------------------------------------
    // üî• CANCELAR auto-scroll si hay intenci√≥n contraria
    // (SIN tocar posici√≥n del rect)
    // ------------------------------------------------
    if (
        autoScrollActivo &&
        (
            (direccionAutoScroll === 1 && ultimaDireccion < 0) ||
            (direccionAutoScroll === -1 && ultimaDireccion > 0)
        )
    ) {
        autoScrollActivo = false;
        direccionAutoScroll = 0;
        return; // üëà el drag normal continuar√° en el siguiente move
    }

    const rangoBorde = 60;
    const distanciaIzquierda = rectRectangulo.left - rectContenedor.left;
    const distanciaDerecha = rectContenedor.right - rectRectangulo.right;

    // ------------------------------------------------
    // Activar auto-scroll SOLO si no est√° activo
    // ------------------------------------------------
    if (!autoScrollActivo) {
        if (distanciaIzquierda <= rangoBorde && ultimaDireccion < 0) {
            autoScrollActivo = true;
            direccionAutoScroll = -1;
            requestAnimationFrame(autoScrollHorizontalContinuo);
            return;
        }

        if (distanciaDerecha <= rangoBorde && ultimaDireccion > 0) {
            autoScrollActivo = true;
            direccionAutoScroll = 1;
            requestAnimationFrame(autoScrollHorizontalContinuo);
            return;
        }
    }

    // ------------------------------------------------
    // Movimiento manual NORMAL (solo si NO hay auto-scroll)
    // ------------------------------------------------
    if (!autoScrollActivo) {
        const deltaX = mouseXRelativo - offsetInicialXContenedor;
        let nuevaPosicion = posicionInicialRect + deltaX;

        nuevaPosicion =
            Math.round((nuevaPosicion - PADDING) / SEGMENTO) * SEGMENTO + PADDING;

        const maxPos =
            60 * PASO_DELTA * MINUTOS_TOTALES * SEGMENTO + PADDING;

        nuevaPosicion = Math.min(
            Math.max(nuevaPosicion, PADDING),
            maxPos - rectanguloArrastrado.offsetWidth
        );

        const indice = parseInt(rectanguloArrastrado.dataset.indice);
        aplicarFisicaEmpuje(indice, nuevaPosicion);
        actualizarPosicionesVisuales();
    }
}

 

 

 
let offsetDentroRectangulo = 0;
 

 

 

 
 
let offsetInicialXContenedor = 0;
let ultimoMouseXRelativo = null;
let ultimaDireccion = 0;
 
// Auto-scroll
let autoScrollActivo = false;
let direccionAutoScroll = 0; // -1 izquierda, 1 derecha  
  
let ultimoTimestampAutoScroll = null;
 
 
let offsetRectanguloEnViewport = 0;


 
 
function iniciarArrastre(e, rect) {
  if (e.target.classList.contains('extremo-blanco')) return;

  opacidad_desplazamiento(rect);

  arrastreActivo = true;
  rectanguloArrastrado = rect;
  rectanguloArrastrado.classList.add('dragging');

  const rectContenedor = contenedor.getBoundingClientRect();
  ultimoMouseXRelativo = e.clientX - rectContenedor.left + scrollWrapper.scrollLeft; 
  ultimaDireccion = 0;

  // Guardamos posici√≥n inicial del rect√°ngulo dentro del contenedor
  posicionInicialRect = parseFloat(rectanguloArrastrado.dataset.xReal);

  // Guardamos offset inicial del mouse **relativo al contenedor**
  offsetInicialXContenedor = e.clientX - rectContenedor.left + scrollWrapper.scrollLeft;

  e.preventDefault();

  document.addEventListener('mousemove', moverRectangulo, { passive: false });
  document.addEventListener('mouseup', finalizarArrastre);
}
 

function moverRectangulo_0(e) {
    if (!arrastreActivo || !rectanguloArrastrado) return;
    e.preventDefault();
    console.log("MOVIENDO...");
    const rectContenedor = contenedor.getBoundingClientRect();
    const rectRectangulo = rectanguloArrastrado.getBoundingClientRect();
    const mouseXRelativo = e.clientX - rectContenedor.left + scrollWrapper.scrollLeft;

    // Direcci√≥n instant√°nea (solo para saber hacia d√≥nde va el mouse, no afecta al rect√°ngulo si hay auto-scroll)
    if (ultimoMouseXRelativo !== null) {
        const deltaInstantaneo = mouseXRelativo - ultimoMouseXRelativo;
        if (deltaInstantaneo !== 0) ultimaDireccion = Math.sign(deltaInstantaneo);
    }
    ultimoMouseXRelativo = mouseXRelativo;

    const rangoBorde = 60; // zona de activaci√≥n
    const distanciaIzquierda = rectRectangulo.left - rectContenedor.left;
    const distanciaDerecha = rectContenedor.right - rectRectangulo.right;

    let enZonaAutoScroll = false;
/* 
    // -----------------------------
    // Activar o desactivar auto-scroll seg√∫n direcci√≥n del mouse
    // -----------------------------
    if (distanciaIzquierda <= rangoBorde && ultimaDireccion < 0) {
        enZonaAutoScroll = true;
        autoScrollActivo = true;
        direccionAutoScroll = -1;
        requestAnimationFrame(autoScrollHorizontalContinuo);
    } else if (distanciaDerecha <= rangoBorde && ultimaDireccion > 0) {
        enZonaAutoScroll = true;
        autoScrollActivo = true;
        direccionAutoScroll = 1;
        requestAnimationFrame(autoScrollHorizontalContinuo);
    } else {
        // Desactivar auto-scroll si el mouse se mueve en direcci√≥n contraria
        autoScrollActivo = false;
        direccionAutoScroll = 0;
    }
*/ 

    // -----------------------------
    // Movimiento manual solo si NO est√° en auto-scroll
    // -----------------------------
//if (!enZonaAutoScroll) {
    if (true) {
        const deltaX = mouseXRelativo - offsetInicialXContenedor;
        let nuevaPosicion = posicionInicialRect + deltaX;

        // Snapping y l√≠mites
        nuevaPosicion = Math.round((nuevaPosicion - PADDING) / SEGMENTO) * SEGMENTO + PADDING;
        const maxPos = 60 * PASO_DELTA * MINUTOS_TOTALES * SEGMENTO + PADDING;
        nuevaPosicion = Math.min(Math.max(nuevaPosicion, PADDING), maxPos - rectanguloArrastrado.offsetWidth);

        const indice = parseInt(rectanguloArrastrado.dataset.indice);
        aplicarFisicaEmpuje(indice, nuevaPosicion);
        actualizarPosicionesVisuales();
 
if (ultimaDireccion < 0) {
        enZonaAutoScroll = true;
        autoScrollActivo = true;
        direccionAutoScroll = -1;
        requestAnimationFrame(autoScrollHorizontalContinuo);
    } else if (ultimaDireccion > 0) {
        enZonaAutoScroll = true;
        autoScrollActivo = true;
        direccionAutoScroll = 1;
        requestAnimationFrame(autoScrollHorizontalContinuo);
 }
    }
}
 

function moverRectanguloTouch(e) {
    if (!arrastreActivo || !rectanguloArrastrado) return;
    
    // Prevenir scroll del navegador
    if (e.cancelable) e.preventDefault();
    
    const touch = e.touches[0];
    if (!touch) return;
    
    console.log("MOVIENDO TOUCH...");
    saveState();
    
    const rectContenedor = contenedor.getBoundingClientRect();
    const mouseXRelativo = touch.clientX - rectContenedor.left + scrollWrapper.scrollLeft;
    
    // Direcci√≥n instant√°nea
    if (ultimoMouseXRelativo !== null) {
        const deltaInstantaneo = mouseXRelativo - ultimoMouseXRelativo;
        if (deltaInstantaneo !== 0) ultimaDireccion = Math.sign(deltaInstantaneo);
    }
    ultimoMouseXRelativo = mouseXRelativo;
    
    const rangoBorde = 60;
    
    // Detectar posici√≥n del TOUCH respecto al viewport
    const touchPosEnViewport = touch.clientX - rectContenedor.left;
    const distanciaMouseIzquierda = touchPosEnViewport;
    const distanciaMouseDerecha = rectContenedor.width - touchPosEnViewport;
    
    // Actualizar posici√≥n del rect√°ngulo SIEMPRE seg√∫n el touch
    const deltaX = mouseXRelativo - offsetInicialXContenedor;
    let nuevaPosicion = posicionInicialRect + deltaX;
    
    // Snapping y l√≠mites
    nuevaPosicion = Math.round((nuevaPosicion - PADDING) / SEGMENTO) * SEGMENTO + PADDING;
    const maxPos = 60 * PASO_DELTA * MINUTOS_TOTALES * SEGMENTO + PADDING;
    nuevaPosicion = Math.min(Math.max(nuevaPosicion, PADDING), maxPos - rectanguloArrastrado.offsetWidth);
    
    // Asegurarse de que siempre haya al menos 80px visibles
    const minVisible = 60;
    if (nuevaPosicion + rectanguloArrastrado.offsetWidth - scrollWrapper.scrollLeft < minVisible) {
        nuevaPosicion = scrollWrapper.scrollLeft + minVisible - rectanguloArrastrado.offsetWidth;
    }
    if (nuevaPosicion - scrollWrapper.scrollLeft > rectContenedor.width - minVisible) {
        nuevaPosicion = scrollWrapper.scrollLeft + rectContenedor.width - minVisible;
    }
    
    const indice = parseInt(rectanguloArrastrado.dataset.indice);
    
    // SIEMPRE actualizar la posici√≥n absoluta (se usa durante auto-scroll)
    posicionAbsolutaInicial = nuevaPosicion;
    
    aplicarFisicaEmpuje(indice, nuevaPosicion);
    actualizarPosicionesVisuales();
    
    // Detectar zona de auto-scroll seg√∫n POSICI√ìN DEL TOUCH en el viewport
    if (distanciaMouseIzquierda < rangoBorde && ultimaDireccion < 0) {
        // Touch cerca del borde izquierdo - scroll hacia la IZQUIERDA
        if (!autoScrollActivo) {
            autoScrollActivo = true;
            direccionAutoScroll = -1;
            ultimoTimestampAutoScroll = null;
            requestAnimationFrame(autoScrollHorizontalContinuo);
        } else if (direccionAutoScroll !== -1) {
            direccionAutoScroll = -1;
        }
    } else if (distanciaMouseDerecha < rangoBorde && ultimaDireccion > 0) {
        // Touch cerca del borde derecho - scroll hacia la DERECHA
        if (!autoScrollActivo) {
            autoScrollActivo = true;
            direccionAutoScroll = 1;
            ultimoTimestampAutoScroll = null;
            requestAnimationFrame(autoScrollHorizontalContinuo);
        } else if (direccionAutoScroll !== 1) {
            direccionAutoScroll = 1;
        }
    } else {
        // Fuera de zonas de auto-scroll
        autoScrollActivo = false;
        direccionAutoScroll = 0;
    }
}

function moverRectangulo(e) {
    if (!arrastreActivo || !rectanguloArrastrado) return;
    e.preventDefault();
    console.log("MOVIENDO...");
    saveState();
    
    const rectContenedor = contenedor.getBoundingClientRect();
    const mouseXRelativo = e.clientX - rectContenedor.left + scrollWrapper.scrollLeft;
    
    // Direcci√≥n instant√°nea
    if (ultimoMouseXRelativo !== null) {
        const deltaInstantaneo = mouseXRelativo - ultimoMouseXRelativo;
        if (deltaInstantaneo !== 0) ultimaDireccion = Math.sign(deltaInstantaneo);
    }
    ultimoMouseXRelativo = mouseXRelativo;
    
    const rangoBorde = 60;
    
    // CAMBIO CLAVE: detectar posici√≥n del MOUSE respecto al viewport
    const mousePosEnViewport = e.clientX - rectContenedor.left;
    const distanciaMouseIzquierda = mousePosEnViewport;
    const distanciaMouseDerecha = rectContenedor.width - mousePosEnViewport;
    
    // Actualizar posici√≥n del rect√°ngulo SIEMPRE seg√∫n el mouse
    const deltaX = mouseXRelativo - offsetInicialXContenedor;
    let nuevaPosicion = posicionInicialRect + deltaX;
    
    // Snapping y l√≠mites
    nuevaPosicion = Math.round((nuevaPosicion - PADDING) / SEGMENTO) * SEGMENTO + PADDING;
    const maxPos = 60 * PASO_DELTA * MINUTOS_TOTALES * SEGMENTO + PADDING;
    nuevaPosicion = Math.min(Math.max(nuevaPosicion, PADDING), maxPos - rectanguloArrastrado.offsetWidth);

// Asegurarse de que siempre haya al menos 60px visibles
const minVisible = 80;
if (nuevaPosicion + rectanguloArrastrado.offsetWidth - scrollWrapper.scrollLeft < minVisible) {
    nuevaPosicion = scrollWrapper.scrollLeft + minVisible - rectanguloArrastrado.offsetWidth;
}
if (nuevaPosicion - scrollWrapper.scrollLeft > rectContenedor.width - minVisible) {
    nuevaPosicion = scrollWrapper.scrollLeft + rectContenedor.width - minVisible;
}

    
    const indice = parseInt(rectanguloArrastrado.dataset.indice);
    
    // SIEMPRE actualizar la posici√≥n absoluta (se usa durante auto-scroll)
    posicionAbsolutaInicial = nuevaPosicion;
    
    aplicarFisicaEmpuje(indice, nuevaPosicion);
    actualizarPosicionesVisuales();
    
    // Detectar zona de auto-scroll seg√∫n POSICI√ìN DEL MOUSE en el viewport
    if (distanciaMouseIzquierda < rangoBorde && ultimaDireccion < 0) {
        // Mouse cerca del borde izquierdo - scroll hacia la IZQUIERDA
        if (!autoScrollActivo) {
            autoScrollActivo = true;
            direccionAutoScroll = -1;
            ultimoTimestampAutoScroll = null;
            requestAnimationFrame(autoScrollHorizontalContinuo);
        } else if (direccionAutoScroll !== -1) {
            direccionAutoScroll = -1;
        }
    } else if (distanciaMouseDerecha < rangoBorde && ultimaDireccion > 0) {
        // Mouse cerca del borde derecho - scroll hacia la DERECHA
        if (!autoScrollActivo) {
            autoScrollActivo = true;
            direccionAutoScroll = 1;
            ultimoTimestampAutoScroll = null;
            requestAnimationFrame(autoScrollHorizontalContinuo);
        } else if (direccionAutoScroll !== 1) {
            direccionAutoScroll = 1;
        }
    } else {
        // Fuera de zonas de auto-scroll
        autoScrollActivo = false;
        direccionAutoScroll = 0;
    }
}

function autoScrollHorizontalContinuo(timestamp) { 
    if (!autoScrollActivo || direccionAutoScroll === 0) return; 
 
    if (ultimoTimestampAutoScroll === null) ultimoTimestampAutoScroll = timestamp; 
    const deltaTime = (timestamp - ultimoTimestampAutoScroll) / 1000; // segundos 
    ultimoTimestampAutoScroll = timestamp; 
 
    const velocidadPxPorSeg = 800; // por ejemplo, 800px/s constante 
    const delta = velocidadPxPorSeg * deltaTime; 
 
    const maxScroll = scrollWrapper.scrollWidth - scrollWrapper.clientWidth; 
    
    // Guardar scroll anterior
    const scrollAnterior = scrollWrapper.scrollLeft;
 
    if (direccionAutoScroll === 1) { 
        scrollWrapper.scrollLeft = Math.min(scrollWrapper.scrollLeft + delta, maxScroll); 
    } else if (direccionAutoScroll === -1) { 
        scrollWrapper.scrollLeft = Math.max(scrollWrapper.scrollLeft - delta, 0); 
    } 
    
    // Calcular cu√°nto SE MOVI√ì REALMENTE el scroll
    const scrollRealMovido = scrollWrapper.scrollLeft - scrollAnterior;
  
    // Mover el rect√°ngulo la misma cantidad que se movi√≥ el scroll
    if (rectanguloArrastrado && posicionAbsolutaInicial !== undefined) { 
        const indice = parseInt(rectanguloArrastrado.dataset.indice); 
        
        // Avanzar la posici√≥n absoluta seg√∫n cu√°nto se movi√≥ el scroll
        posicionAbsolutaInicial += scrollRealMovido;
        
        // Aplicar l√≠mites
        const maxPos = 60 * PASO_DELTA * MINUTOS_TOTALES * SEGMENTO + PADDING;
        posicionAbsolutaInicial = Math.min(Math.max(posicionAbsolutaInicial, PADDING), maxPos - rectanguloArrastrado.offsetWidth);
        
        aplicarFisicaEmpuje(indice, posicionAbsolutaInicial); 
        actualizarPosicionesVisuales(); 
    } 
  
    requestAnimationFrame(autoScrollHorizontalContinuo); 
}
 
function autoScrollHorizontalContinuo_0(timestamp) {
    if (!autoScrollActivo || direccionAutoScroll === 0) return;

    if (ultimoTimestampAutoScroll === null) ultimoTimestampAutoScroll = timestamp;
    const deltaTime = (timestamp - ultimoTimestampAutoScroll) / 1000; // segundos
    ultimoTimestampAutoScroll = timestamp;

    const velocidadPxPorSeg = 800; // por ejemplo, 200px/s constante
    const delta = velocidadPxPorSeg * deltaTime;

    const maxScroll = scrollWrapper.scrollWidth - scrollWrapper.clientWidth;

    if (direccionAutoScroll === 1) {
        scrollWrapper.scrollLeft = Math.min(scrollWrapper.scrollLeft + delta, maxScroll);
    } else if (direccionAutoScroll === -1) {
        scrollWrapper.scrollLeft = Math.max(scrollWrapper.scrollLeft - delta, 0);
    }
 
/* 
    // Mantener rect√°ngulo pegado al borde visible
    if (rectanguloArrastrado) {
        const indice = parseInt(rectanguloArrastrado.dataset.indice);
        let nuevaPos;
 
        if (direccionAutoScroll === 1) {
            nuevaPos = scrollWrapper.scrollLeft + scrollWrapper.clientWidth - rectanguloArrastrado.offsetWidth - PADDING;
        } else {
            nuevaPos = scrollWrapper.scrollLeft + PADDING;
        }
 
        aplicarFisicaEmpuje(indice, nuevaPos);
        actualizarPosicionesVisuales();
    }
*/
 
 
    requestAnimationFrame(autoScrollHorizontalContinuo);
}

function finalizarArrastre() { 
    autoScrollActivo = false;
    direccionAutoScroll = 0;
    ultimoTimestampAutoScroll = null;

    if (rectanguloArrastrado) {
        rectanguloArrastrado.classList.remove('dragging');
        actualizarEstadoGlobal();//descomentar
	console.log("finalizarArrastre: ",finalizarArrastre);
        crearBotonMas();
    }
    arrastreActivo = false;
    rectanguloArrastrado = null;

    document.removeEventListener('mousemove', moverRectangulo);
    document.removeEventListener('mouseup', finalizarArrastre);
    saveState();
    opacidad_reposo(selected_rect);
    ajustarRectangulosMove();
}

 
 
 
 


//60*5*2*40+PADDING 


 
 

 

function autoScrollHorizontal() {
    const scrollRect = scrollWrapper.getBoundingClientRect();
    const rect = rectanguloArrastrado.getBoundingClientRect();

    const edge = 60;
    const speed = 16;

    const tocaIzq = rect.left < scrollRect.left + edge;
    const tocaDer = rect.right > scrollRect.right - edge;

    // Caso normal
    if (tocaDer && !tocaIzq) {
        scrollWrapper.scrollLeft += speed;
        return;
    }

    if (tocaIzq && !tocaDer) {
        scrollWrapper.scrollLeft -= speed;
        return;
    }

    // ‚ö†Ô∏è Caso especial: toca ambos lados
    if (tocaIzq && tocaDer) {
        if (ultimaDireccion > 0) {
            scrollWrapper.scrollLeft += speed;
        } else if (ultimaDireccion < 0) {
            scrollWrapper.scrollLeft -= speed;
        }
    }
}

  
 
 

function finalizarArrastreTouch() { 
    autoScrollActivo = false;
    direccionAutoScroll = 0;
    ultimoTimestampAutoScroll = null;
 

    if (rectanguloArrastrado) {
        rectanguloArrastrado.classList.remove('dragging');
        actualizarEstadoGlobal(); // descomentar si lo necesitas
        console.log("finalizarArrastreTouch: ", finalizarArrastreTouch);
        crearBotonMas();
    }

    arrastreActivo = false;
    rectanguloArrastrado = null;
 
    document.removeEventListener('touchmove', moverRectanguloTouch);
    document.removeEventListener('touchend', finalizarArrastreTouch);
    //document.removeEventListener('touchcancel', finalizarArrastreTouch);
    saveState();
    opacidad_reposo(selected_rect);
}


 

 
  
function aplicarFisicaEmpuje(indice, nuevaPosicion) {
    const rectActual = rectangulos[indice];
    const posicionActual = parseFloat(rectActual.posicion);
    const delta = nuevaPosicion - posicionActual;

    // Copiar todas las posiciones actuales
    let posicionesNuevas = rectangulos.map(r => parseFloat(r.posicion));
    posicionesNuevas[indice] = nuevaPosicion;

    if (delta > 0) {
        // Moviendo a la derecha - empujar rect√°ngulos a la derecha
        for (let i = indice + 1; i < rectangulos.length; i++) {
            const anchoAnterior = parseFloat(rectangulos[i - 1].ancho);
            const finAnterior = posicionesNuevas[i - 1] + anchoAnterior;
            
            if (finAnterior > posicionesNuevas[i]) {
                posicionesNuevas[i] = finAnterior;
            } else {
                break;
            }
        }
    } else if (delta < 0) {
        // Moviendo a la izquierda - empujar rect√°ngulos a la izquierda
        for (let i = indice - 1; i >= 0; i--) {
            const anchoActual = parseFloat(rectangulos[i].ancho);
            const inicioSiguiente = posicionesNuevas[i + 1];
            const finActual = posicionesNuevas[i] + anchoActual;
            
            if (finActual > inicioSiguiente) {
                posicionesNuevas[i] = inicioSiguiente - anchoActual;
            } else {
                break;
            }
        }

        // Verificar si alg√∫n rect√°ngulo se sali√≥ de la pared
        let necesitaReajuste = false;
        let indiceConflicto = -1;
        for (let i = 0; i < rectangulos.length; i++) {
            if (posicionesNuevas[i] < PADDING) {
                necesitaReajuste = true;
                indiceConflicto = i;
                break;
            }
        }

        if (necesitaReajuste) {
            // Reajustar desde la pared hacia la derecha
            posicionesNuevas[indiceConflicto] = PADDING;
            
            // Propagar hacia la derecha empujando todos los rect√°ngulos
            for (let i = indiceConflicto + 1; i < rectangulos.length; i++) {
                const anchoAnterior = parseFloat(rectangulos[i - 1].ancho);
                const finAnterior = posicionesNuevas[i - 1] + anchoAnterior;
                
                // Siempre pegar al anterior cuando hay reajuste desde la pared
                if (posicionesNuevas[i] < finAnterior) {
                    posicionesNuevas[i] = finAnterior;
                }
            }
        }
    }

    // Verificaci√≥n final: asegurar que NO haya superposiciones
    for (let i = 0; i < rectangulos.length - 1; i++) {
        const anchoActual = parseFloat(rectangulos[i].ancho);
        const finActual = posicionesNuevas[i] + anchoActual;
        const inicioSiguiente = posicionesNuevas[i + 1];
        
        if (finActual > inicioSiguiente) {
            // Hay superposici√≥n, forzar separaci√≥n
            posicionesNuevas[i + 1] = finActual;
        }
    }

    // Aplicar todas las posiciones
    for (let i = 0; i < rectangulos.length; i++) {
        rectangulos[i].posicion = posicionesNuevas[i];
        rectangulos[i].elemento.dataset.xReal = posicionesNuevas[i];
    }
    console.log("000000rectangulos: ",JSON.stringify(rectangulos));
}


function aplicarFisicaEmpuje_2(indice, nuevaPosicion) {
    const rectActual = rectangulos[indice];
    const posicionActual = parseFloat(rectActual.posicion);
    const delta = nuevaPosicion - posicionActual;
    const anchoActual = parseFloat(rectActual.ancho);

    // Calcular huecos originales entre los rect√°ngulos que NO son el arrastrado
    const huecosOriginales = [];
    for (let i = 0; i < rectangulos.length - 1; i++) {
        const finActual = parseFloat(rectangulos[i].posicion) + parseFloat(rectangulos[i].ancho);
        const inicioSiguiente = parseFloat(rectangulos[i + 1].posicion);
        huecosOriginales[i] = Math.max(0, inicioSiguiente - finActual);
    }

    // Copiar todas las posiciones actuales
    let posicionesNuevas = rectangulos.map(r => parseFloat(r.posicion));
    posicionesNuevas[indice] = nuevaPosicion;

    if (delta > 0) {
        // Moviendo a la derecha
        const finRectArrastrado = nuevaPosicion + anchoActual;
        
        // Solo empujar si toca al siguiente
        if (indice < rectangulos.length - 1) {
            const inicioSiguiente = parseFloat(rectangulos[indice + 1].posicion);
            
            if (finRectArrastrado > inicioSiguiente) {
                // Empujar todos los de la derecha manteniendo sus huecos internos
                const desplazamiento = finRectArrastrado - inicioSiguiente;
                
                for (let i = indice + 1; i < rectangulos.length; i++) {
                    if (i === indice + 1) {
                        // El primero se pega al arrastrado
                        posicionesNuevas[i] = finRectArrastrado;
                    } else {
                        // Los dem√°s mantienen su hueco con el anterior
                        const anchoAnterior = parseFloat(rectangulos[i - 1].ancho);
                        const finAnterior = posicionesNuevas[i - 1] + anchoAnterior;
                        const huecoAMantener = huecosOriginales[i - 1];
                        posicionesNuevas[i] = finAnterior + huecoAMantener;
                    }
                }
            }
        }
        
    } else if (delta < 0) {
        // Moviendo a la izquierda
        
        // Solo empujar si toca al anterior
        if (indice > 0) {
            const anteriorFin = parseFloat(rectangulos[indice - 1].posicion) + parseFloat(rectangulos[indice - 1].ancho);
            
            if (nuevaPosicion < anteriorFin) {
                // Empujar todos los de la izquierda manteniendo sus huecos internos
                const desplazamiento = anteriorFin - nuevaPosicion;
                
                for (let i = indice - 1; i >= 0; i--) {
                    if (i === indice - 1) {
                        // El primero se empuja directamente
                        const anchoI = parseFloat(rectangulos[i].ancho);
                        posicionesNuevas[i] = nuevaPosicion - anchoI;
                    } else {
                        // Los dem√°s mantienen su hueco con el siguiente
                        const inicioSiguiente = posicionesNuevas[i + 1];
                        const huecoAMantener = huecosOriginales[i];
                        const anchoI = parseFloat(rectangulos[i].ancho);
                        posicionesNuevas[i] = inicioSiguiente - huecoAMantener - anchoI;
                    }
                    
                    // Detener si choca con la pared
                    if (posicionesNuevas[i] < PADDING) {
                        posicionesNuevas[i] = PADDING;
                        
                        // Reajustar todos hacia la derecha desde aqu√≠
                        for (let j = i + 1; j <= indice; j++) {
                            if (j === i + 1) {
                                const anchoAnterior = parseFloat(rectangulos[j - 1].ancho);
                                const finAnterior = posicionesNuevas[j - 1] + anchoAnterior;
                                const huecoAMantener = huecosOriginales[j - 1];
                                posicionesNuevas[j] = finAnterior + huecoAMantener;
                            } else if (j < indice) {
                                const anchoAnterior = parseFloat(rectangulos[j - 1].ancho);
                                const finAnterior = posicionesNuevas[j - 1] + anchoAnterior;
                                const huecoAMantener = huecosOriginales[j - 1];
                                posicionesNuevas[j] = finAnterior + huecoAMantener;
                            } else {
                                // El arrastrado se pega al anterior
                                const anchoAnterior = parseFloat(rectangulos[j - 1].ancho);
                                const finAnterior = posicionesNuevas[j - 1] + anchoAnterior;
                                posicionesNuevas[j] = finAnterior;
                            }
                        }
                        break;
                    }
                }
            }
        }
    }

    // Aplicar todas las posiciones
    for (let i = 0; i < rectangulos.length; i++) {
        rectangulos[i].posicion = posicionesNuevas[i];
        rectangulos[i].elemento.dataset.xReal = posicionesNuevas[i];
    }
}

 
 
 

function iniciarRedimensionTouch(e, rect, lado) {
    if (!e.touches || e.touches.length === 0) return;

    console.log("REDIMENSION TOUCH");
    redimensionActiva = true;
    rectanguloRedimensionado = rect;
    ladoRedimension = lado;

    // Guardar estado inicial
    scrollInicialAuto = scrollWrapper.scrollLeft;
    anchoInicialAuto = anchoInicial;

    if (ladoRedimension === 'derecho') {
        bordeFijoAuto = posicionInicialRectRedim; // borde izquierdo fijo
    } else {
        bordeFijoAuto = posicionInicialRectRedim + anchoInicial; // borde derecho fijo
    }

    scrollInicial = scrollWrapper.scrollLeft;

    // Posici√≥n inicial del touch
    posicionInicialMouse = e.touches[0].clientX;

    anchoInicial = parseFloat(rect.dataset.widthReal);
    posicionInicialRectRedim = parseFloat(rect.dataset.xReal);

    // Eventos touch
    document.addEventListener('touchmove', redimensionarRectanguloTouch, { passive: false });
    document.addEventListener('touchend', finalizarRedimensionTouch);

    e.stopPropagation();
    //e.preventDefault();
    if (e.touches && e.touches.length > 0) {
    	if (e.cancelable) e.preventDefault();
    }
}


 



let scrollInicial;

 
let bordeFijoAuto = 0; 
let anchoInicialAuto = 0;
let scrollInicialAuto = 0;
 
function iniciarRedimension(e, rect, lado) {
    redimensionActiva = true;
    rectanguloRedimensionado = rect;
    ladoRedimension = lado;

    scrollInicialAuto = scrollWrapper.scrollLeft;
    anchoInicialAuto = anchoInicial;

    if (ladoRedimension === 'derecho') {
    	bordeFijoAuto = posicionInicialRectRedim; // borde izquierdo fijo
    } else {
    	bordeFijoAuto = posicionInicialRectRedim + anchoInicial; // borde derecho fijo
    } 


    scrollInicial = scrollWrapper.scrollLeft;


    posicionInicialMouse = e.clientX;
    anchoInicial = parseFloat(rect.dataset.widthReal);
    posicionInicialRectRedim = parseFloat(rect.dataset.xReal); 

    document.addEventListener('mousemove', redimensionarRectangulo);
    document.addEventListener('mouseup', finalizarRedimension);

    e.stopPropagation();
    e.preventDefault();
}

 

 
let ultimoMouseXPantalla = 0;
 
/*modificar*/ 
  


function autoScrollHorizontalContinuoRedim_xd(timestamp) {
    if (!autoScrollActivo || direccionAutoScroll === 0) return;

    if (ultimoTimestampAutoScroll === null)
        ultimoTimestampAutoScroll = timestamp;

    const deltaTime = (timestamp - ultimoTimestampAutoScroll) / 1000;
    ultimoTimestampAutoScroll = timestamp;

    const velocidadPxPorSeg = 800;
    const delta = velocidadPxPorSeg * deltaTime;

    const maxScroll = scrollWrapper.scrollWidth - scrollWrapper.clientWidth;

    if (direccionAutoScroll === 1) {
        scrollWrapper.scrollLeft = Math.min(
            scrollWrapper.scrollLeft + delta,
            maxScroll
        );
    } else {
        scrollWrapper.scrollLeft = Math.max(
            scrollWrapper.scrollLeft - delta,
            0
        );
    }

    if (rectanguloRedimensionado) {
        const indice = parseInt(rectanguloRedimensionado.dataset.indice);
        const rectActual = rectangulos[indice];

        if (ladoRedimension === 'derecho') {
            const bordeVisible =
                scrollWrapper.scrollLeft +
                scrollWrapper.clientWidth -
                PADDING;

            let nuevoAncho = bordeVisible - bordeFijoAuto;
            if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

            // ‚¨ÖÔ∏è GUARDAR ANCHO ANTERIOR
            const anchoAnterior = parseFloat(rectActual.ancho);

            rectActual.ancho = nuevoAncho;
            rectActual.elemento.dataset.widthReal = nuevoAncho;

            // ‚¨ÖÔ∏è DETECTAR COLISI√ìN Y EMPUJAR
            const posActual = parseFloat(rectActual.posicion);
            if (nuevoAncho > anchoAnterior && indice < rectangulos.length - 1) {
                const rectDerecha = rectangulos[indice + 1];
                const posDerecha = parseFloat(rectDerecha.posicion);

                if (posActual + nuevoAncho >= posDerecha) {
                    const desplazamiento = (posActual + nuevoAncho) - posDerecha;
                    aplicarEmpujeRedimension(indice + 1, desplazamiento, 'derecha');
                }
            }
        }

        if (ladoRedimension === 'izquierdo') {
            const bordeVisible = scrollWrapper.scrollLeft + PADDING;

            let nuevaPos = bordeVisible;

            let nuevoAncho = bordeFijoAuto - nuevaPos;
            if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

            // ‚¨ÖÔ∏è GUARDAR POSICI√ìN ANTERIOR
            const posAnterior = parseFloat(rectActual.posicion);

            rectActual.posicion = nuevaPos;
            rectActual.elemento.dataset.xReal = nuevaPos;
            rectActual.ancho = nuevoAncho;
            rectActual.elemento.dataset.widthReal = nuevoAncho;

            // ‚¨ÖÔ∏è DETECTAR COLISI√ìN Y EMPUJAR (lado izquierdo)
            if (nuevaPos < posAnterior && indice > 0) {
                const rectIzquierda = rectangulos[indice - 1];
                const bordeDerechoIzq = parseFloat(rectIzquierda.posicion) + 
                                       parseFloat(rectIzquierda.ancho);

                if (nuevaPos < bordeDerechoIzq) {
                    const desplazamiento = bordeDerechoIzq - nuevaPos;
                    aplicarEmpujeRedimension(indice - 1, desplazamiento, 'izquierda');
                }
            }
        }

        actualizarPosicionesVisuales();
    }

    requestAnimationFrame(autoScrollHorizontalContinuoRedim);
}



function autoScrollHorizontalContinuoRedim(timestamp) {
    if (!autoScrollActivo || direccionAutoScroll === 0) return;
 
    if (ultimoTimestampAutoScroll === null)
        ultimoTimestampAutoScroll = timestamp;

    const deltaTime = (timestamp - ultimoTimestampAutoScroll) / 1000;
    ultimoTimestampAutoScroll = timestamp;

    const velocidadPxPorSeg = 800;
    const delta = velocidadPxPorSeg * deltaTime;

    const maxScroll = scrollWrapper.scrollWidth - scrollWrapper.clientWidth;

    if (direccionAutoScroll === 1) {
        scrollWrapper.scrollLeft = Math.min(
            scrollWrapper.scrollLeft + delta,
            maxScroll
        );
    } else {
        scrollWrapper.scrollLeft = Math.max(
            scrollWrapper.scrollLeft - delta,
            0
        );
    }

    if (rectanguloRedimensionado) {
        const indice = parseInt(rectanguloRedimensionado.dataset.indice);
        const rectActual = rectangulos[indice];

        if (ladoRedimension === 'derecho' && direccionAutoScroll === 1) {
            const bordeVisible =
                scrollWrapper.scrollLeft +
                scrollWrapper.clientWidth -
                PADDING;

            let nuevoAncho = bordeVisible - bordeFijoAuto;
            if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

            // ‚¨ÖÔ∏è GUARDAR ANCHO ANTERIOR
            const anchoAnterior = parseFloat(rectActual.ancho);

            rectActual.ancho = nuevoAncho;
            rectActual.elemento.dataset.widthReal = nuevoAncho;

            // ‚¨ÖÔ∏è DETECTAR COLISI√ìN Y EMPUJAR
            const posActual = parseFloat(rectActual.posicion);
            if (nuevoAncho > anchoAnterior && indice < rectangulos.length - 1) {
                const rectDerecha = rectangulos[indice + 1];
                const posDerecha = parseFloat(rectDerecha.posicion);

                if (posActual + nuevoAncho >= posDerecha) {
                    const desplazamiento = (posActual + nuevoAncho) - posDerecha;
                    aplicarEmpujeRedimension(indice + 1, desplazamiento, 'derecha');
                } 
            } 
        }


        if (ladoRedimension === 'derecho' && direccionAutoScroll === -1) {
            const bordeVisibleDerecho = scrollWrapper.scrollLeft + 60;
            const posActual = parseFloat(rectActual.posicion);

            let nuevoAncho = bordeVisibleDerecho - posActual;
            if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

            rectActual.ancho = nuevoAncho;
            rectActual.elemento.dataset.widthReal = nuevoAncho;
        }
        if (ladoRedimension === 'izquierdo' && direccionAutoScroll === -1) {
            const bordeVisible = scrollWrapper.scrollLeft + PADDING;

            let nuevaPos = bordeVisible;

            let nuevoAncho = bordeFijoAuto - nuevaPos;
            if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

            // ‚¨ÖÔ∏è GUARDAR POSICI√ìN ANTERIOR
            const posAnterior = parseFloat(rectActual.posicion);

            rectActual.posicion = nuevaPos;
            rectActual.elemento.dataset.xReal = nuevaPos;
            rectActual.ancho = nuevoAncho;
            rectActual.elemento.dataset.widthReal = nuevoAncho;

            // ‚¨ÖÔ∏è DETECTAR COLISI√ìN Y EMPUJAR (lado izquierdo)
            if (nuevaPos < posAnterior && indice > 0) {
                const rectIzquierda = rectangulos[indice - 1];
                const bordeDerechoIzq = parseFloat(rectIzquierda.posicion) + 
                                       parseFloat(rectIzquierda.ancho);

                if (nuevaPos < bordeDerechoIzq) {
                    const desplazamiento = bordeDerechoIzq - nuevaPos;
                    aplicarEmpujeRedimension(indice - 1, desplazamiento, 'izquierda');
                }
            }
        }
        if (ladoRedimension === 'izquierdo' && direccionAutoScroll === 1) {
            const bordeVisibleIzquierdo = scrollWrapper.scrollLeft + scrollWrapper.clientWidth - 60;
            const bordeDerechoFijo = bordeFijoAuto;

            let nuevoAncho = bordeDerechoFijo - bordeVisibleIzquierdo;
            if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

            let nuevaPos = bordeDerechoFijo - nuevoAncho;

            rectActual.posicion = nuevaPos;
            rectActual.elemento.dataset.xReal = nuevaPos;
            rectActual.ancho = nuevoAncho;
            rectActual.elemento.dataset.widthReal = nuevoAncho;
        }

        actualizarPosicionesVisuales();
    }

    requestAnimationFrame(autoScrollHorizontalContinuoRedim);
}



 


function normalizarAGrilla() {
    for (let i = 0; i < rectangulos.length; i++) {
        const rect = rectangulos[i];

        rect.posicion =
            Math.round(rect.posicion / SEGMENTO) * SEGMENTO;
        rect.ancho =
            Math.round(rect.ancho / SEGMENTO) * SEGMENTO;

        rect.elemento.dataset.xReal = rect.posicion;
        rect.elemento.dataset.widthReal = rect.ancho;
    }

    actualizarPosicionesVisuales();
}


function normalizarAGrillaVideoSpeed() {  
    for (let i = 0; i < rectangulos.length; i++) {
        const rect = rectangulos[i];
	if (!rect.elemento) return;
	const rect_position = Math.round(rect.posicion);
	const rect_ancho = Math.round(rect.ancho);

        rect.posicion = Math.floor(rect_position / SEGMENTO) * SEGMENTO;
 
        rect.ancho = Math.floor(rect_ancho / SEGMENTO) * SEGMENTO;

        rect.elemento.dataset.xReal = rect.posicion;
        rect.elemento.dataset.widthReal = rect.ancho;
    }

    actualizarPosicionesVisuales(); 
}

function normalizarAGrillaVideoSpeed_00() { 
    const PRECISION = 10; // subdivisiones por segmento (1 decimal)

    for (let i = 0; i < rectangulos.length; i++) {
        const rect = rectangulos[i];

        // redondear posici√≥n a 1 decimal relativo a SEGMENTO
        rect.posicion =
            Math.round(rect.posicion / SEGMENTO * PRECISION) / PRECISION * SEGMENTO;

        // redondear ancho y asegurar m√≠nimo de 40
        rect.ancho =
            Math.max(
                Math.round(rect.ancho / SEGMENTO * PRECISION) / PRECISION * SEGMENTO,
                SEGMENTO // ancho m√≠nimo 40
            );

        // actualizar atributos del DOM
        rect.elemento.dataset.xReal = rect.posicion;
        rect.elemento.dataset.widthReal = rect.ancho;
    }

    actualizarPosicionesVisuales();
}





 

function redimensionarRectangulo(e) { 

    if (!redimensionActiva || !rectanguloRedimensionado) return;

    // ===============================
    // 1Ô∏è‚É£ Posici√≥n del mouse EN LA PANTALLA (sin scroll)
    // =============================== 

saveState();

    const rectContenedor = contenedor.getBoundingClientRect();
    const mouseXPantalla = e.clientX - rectContenedor.left;  

    // ‚¨ÖÔ∏è Durante auto-scroll, detectar direcci√≥n usando posici√≥n en pantalla
    if (autoScrollActivo) {
        if (ultimoMouseXPantalla !== null) {
            const deltaInstantaneo = mouseXPantalla - ultimoMouseXPantalla;
            if (deltaInstantaneo !== 0) {
                const direccionInstantanea = Math.sign(deltaInstantaneo);
                
                // Detectar cambio de direcci√≥n opuesta
                if ((direccionAutoScroll === 1 && direccionInstantanea < 0) ||
                    (direccionAutoScroll === -1 && direccionInstantanea > 0)) {
                    
                    // ‚¨ÖÔ∏è CANCELAR AUTO-SCROLL
                    autoScrollActivo = false;
                    direccionAutoScroll = 0;
                    ultimoTimestampAutoScroll = null; 

                    // ‚¨ÖÔ∏è RESETEAR TODO AL ESTADO ACTUAL
                    posicionInicialMouse = e.clientX;
                    scrollInicial = scrollWrapper.scrollLeft;
                    anchoInicial = parseFloat(rectanguloRedimensionado.dataset.widthReal);
                    posicionInicialRectRedim = parseFloat(rectanguloRedimensionado.dataset.xReal);
                    ultimaDireccion = direccionInstantanea;
                    ultimoMouseXPantalla = mouseXPantalla;
                    
                    // NO hacer return, continuar con l√≥gica manual
                } else { 
                    // ‚¨ÖÔ∏è Misma direcci√≥n: actualizar y salir
                    ultimoMouseXPantalla = mouseXPantalla;
                    return; 
                }
            } else {
                return;
            }
        } else {
            ultimoMouseXPantalla = mouseXPantalla;
            return;
        }
    }

    // ===============================
    // Modo manual: usar mouseXRelativo (con scroll)
    // ===============================
    const mouseXRelativo = e.clientX - rectContenedor.left + scrollWrapper.scrollLeft;

    if (ultimoMouseXRelativo !== null) {
        const deltaInstantaneo = mouseXRelativo - ultimoMouseXRelativo;
        if (deltaInstantaneo !== 0)
            ultimaDireccion = Math.sign(deltaInstantaneo);
    }
    ultimoMouseXRelativo = mouseXRelativo;
    ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Actualizar tambi√©n

    // ===============================
    // 2Ô∏è‚É£ Detectar zona de auto-scroll
    // ===============================
    const rectVisual = rectanguloRedimensionado.getBoundingClientRect();

    const rangoBorde = 60;
    const distanciaDerecha = rectContenedor.right - rectVisual.right;
    const distanciaIzquierda = rectVisual.left - rectContenedor.left;

 
//de aqui
const bordeDerechoRect = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                         parseFloat(rectanguloRedimensionado.dataset.widthReal);
const bordeIzquierdoVisible = scrollWrapper.scrollLeft;
const distanciaBordeDerechoAlIzquierdo = bordeDerechoRect - bordeIzquierdoVisible;

if (ladoRedimension === 'derecho' && distanciaBordeDerechoAlIzquierdo <= 60 && ultimaDireccion < 0) {
    console.log('üî¥ Los √∫ltimos 60px del rect√°ngulo est√°n dentro de los 60px del extremo izquierdo');
    
    if (!autoScrollActivo) {
        bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal);  // ‚¨ÖÔ∏è POSICI√ìN IZQUIERDA, NO DERECHA
        autoScrollActivo = true;
        direccionAutoScroll = -1;
        ultimoMouseXPantalla = mouseXPantalla;
        requestAnimationFrame(autoScrollHorizontalContinuoRedim);
    }
    return;
}
const bordeIzquierdoRect = parseFloat(rectanguloRedimensionado.dataset.xReal);
const bordeDerechoVisible = scrollWrapper.scrollLeft + scrollWrapper.clientWidth;
const distanciaBordeIzquierdoAlDerecho = bordeDerechoVisible - bordeIzquierdoRect;

if (ladoRedimension === 'izquierdo' && distanciaBordeIzquierdoAlDerecho <= 60 && ultimaDireccion > 0) {
    console.log('üî¥ Los primeros 60px del rect√°ngulo est√°n dentro de los 60px del extremo derecho');
    
    if (!autoScrollActivo) {
        bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                        parseFloat(rectanguloRedimensionado.dataset.widthReal);  // ‚¨ÖÔ∏è BORDE DERECHO FIJO
        autoScrollActivo = true;
        direccionAutoScroll = 1;  // ‚¨ÖÔ∏è HACIA LA DERECHA
        ultimoMouseXPantalla = mouseXPantalla;
        requestAnimationFrame(autoScrollHorizontalContinuoRedim);
    }
    return;
}
//hasta aqui
 

    if (
        ladoRedimension === 'derecho' &&
        distanciaDerecha <= rangoBorde &&
        ultimaDireccion > 0
    ) {
        if (!autoScrollActivo) {
            bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal);
            autoScrollActivo = true;
            direccionAutoScroll = 1;
            ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Guardar posici√≥n inicial
            requestAnimationFrame(autoScrollHorizontalContinuoRedim);
        }
        return;
    } else if (
        ladoRedimension === 'izquierdo' &&
        distanciaIzquierda <= rangoBorde &&
        ultimaDireccion < 0
    ) {
        if (!autoScrollActivo) {
            bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                            parseFloat(rectanguloRedimensionado.dataset.widthReal);
            autoScrollActivo = true;
            direccionAutoScroll = -1;
            ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Guardar posici√≥n inicial
            requestAnimationFrame(autoScrollHorizontalContinuoRedim);
        }
        return;
    }

    // ===============================
    // 3Ô∏è‚É£ DeltaX (mouse en modo manual)
    // ===============================
    const deltaX = (e.clientX - posicionInicialMouse) +
                   (scrollWrapper.scrollLeft - scrollInicial);

 
    // ===============================
    // ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è L√ìGICA DE REDIMENSI√ìN MANUAL ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
    // ===============================

    const indice = parseInt(rectanguloRedimensionado.dataset.indice);
    const rectActual = rectangulos[indice];

    if (ladoRedimension === 'derecho') {
        let nuevoAncho = anchoInicial + deltaX;
        nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;
        if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

        const posActual = parseFloat(rectActual.posicion);

        if (nuevoAncho > anchoInicial && indice < rectangulos.length - 1) {
            const rectDerecha = rectangulos[indice + 1];
            const posDerecha = parseFloat(rectDerecha.posicion);

            if (posActual + nuevoAncho >= posDerecha) {
                const desplazamiento =
                    (posActual + nuevoAncho) - posDerecha;
                aplicarEmpujeRedimension(
                    indice + 1,
                    desplazamiento,
                    'derecha'
                );
            }
        }

        rectActual.ancho = nuevoAncho;
        rectActual.elemento.dataset.widthReal = nuevoAncho;

    } else if (ladoRedimension === 'izquierdo') {

    let nuevoAncho = anchoInicial - deltaX;
    nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;
    if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

    let nuevaPosicion = posicionInicialRectRedim + (anchoInicial - nuevoAncho);
    const rectRight = posicionInicialRectRedim + anchoInicial;

    if (indice > 0) {
        const rectPrev = rectangulos[indice - 1];
        const bordeDerechoPrev = parseFloat(rectPrev.posicion) + parseFloat(rectPrev.ancho);

        if (nuevaPosicion < bordeDerechoPrev) {
            // ‚¨ÖÔ∏è HAY COLISI√ìN: EMPUJAR el rect√°ngulo anterior hacia la izquierda
            const desplazamiento = bordeDerechoPrev - nuevaPosicion;
            aplicarEmpujeRedimension(indice - 1, desplazamiento, 'izquierda');
            
            // ‚¨ÖÔ∏è Despu√©s de empujar, el rect√°ngulo anterior se habr√° movido
            // Recalcular su nuevo borde derecho
            const nuevobordeDerechoPrev = parseFloat(rectPrev.posicion) + parseFloat(rectPrev.ancho);
            
            // Si el empuje fue bloqueado (lleg√≥ a PADDING), ajustar nuevaPosicion
            if (nuevobordeDerechoPrev > nuevaPosicion) {
                nuevaPosicion = nuevobordeDerechoPrev;
            }
        }
    } else {
        if (nuevaPosicion < PADDING) nuevaPosicion = PADDING;
    }

    const limiteDerecho = rectRight - SEGMENTO;
    if (nuevaPosicion > limiteDerecho) nuevaPosicion = limiteDerecho;

    nuevaPosicion = Math.round(nuevaPosicion / SEGMENTO) * SEGMENTO;
    nuevoAncho = rectRight - nuevaPosicion;
    
    if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;
    nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;

    rectActual.posicion = nuevaPosicion;
    rectActual.elemento.dataset.xReal = nuevaPosicion;
    rectActual.ancho = nuevoAncho;
    rectActual.elemento.dataset.widthReal = nuevoAncho;
}

/*
else if (ladoRedimension === 'izquierdo') {

        let nuevoAncho = anchoInicial - deltaX;
        nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;
        if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

        let nuevaPosicion =
            posicionInicialRectRedim +
            (anchoInicial - nuevoAncho);

        const rectRight =
            posicionInicialRectRedim + anchoInicial;

        if (indice > 0) {
            const rectPrev = rectangulos[indice - 1];
            const bordeDerechoPrev =
                parseFloat(rectPrev.posicion) +
                parseFloat(rectPrev.ancho);

            if (nuevaPosicion < bordeDerechoPrev) {
                nuevaPosicion = bordeDerechoPrev;
            }
        } else {
            if (nuevaPosicion < PADDING)
                nuevaPosicion = PADDING;
        }

        const limiteDerecho = rectRight - SEGMENTO;
        if (nuevaPosicion > limiteDerecho)
            nuevaPosicion = limiteDerecho;

        nuevaPosicion =
            Math.round(nuevaPosicion / SEGMENTO) * SEGMENTO;

        nuevoAncho = rectRight - nuevaPosicion;
        if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;
        nuevoAncho =
            Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;

        rectActual.posicion = nuevaPosicion;
        rectActual.elemento.dataset.xReal = nuevaPosicion;
        rectActual.ancho = nuevoAncho;
        rectActual.elemento.dataset.widthReal = nuevoAncho;
    }
*/

    actualizarPosicionesVisuales();
}



function redimensionarRectanguloTouch(e) {
 
    if (!redimensionActiva || !rectanguloRedimensionado) return;

saveState();

    // ===============================
    // 1Ô∏è‚É£ Posici√≥n del mouse EN LA PANTALLA (sin scroll)
    // ===============================
    let clientX;
    if (e.type.startsWith('touch')) {
        clientX = e.touches[0].clientX; // para touch
    } else {
        clientX = e.clientX; // para mouse
    } 

    const rectContenedor = contenedor.getBoundingClientRect();
    const mouseXPantalla = clientX - rectContenedor.left;  

    // ‚¨ÖÔ∏è Durante auto-scroll, detectar direcci√≥n usando posici√≥n en pantalla
    if (autoScrollActivo) {
        if (ultimoMouseXPantalla !== null) {
            const deltaInstantaneo = mouseXPantalla - ultimoMouseXPantalla;
            if (deltaInstantaneo !== 0) {
                const direccionInstantanea = Math.sign(deltaInstantaneo);
                
                // Detectar cambio de direcci√≥n opuesta
                if ((direccionAutoScroll === 1 && direccionInstantanea < 0) ||
                    (direccionAutoScroll === -1 && direccionInstantanea > 0)) {
                    
                    // ‚¨ÖÔ∏è CANCELAR AUTO-SCROLL
                    autoScrollActivo = false;
                    direccionAutoScroll = 0;
                    ultimoTimestampAutoScroll = null; 

 

                    // ‚¨ÖÔ∏è RESETEAR TODO AL ESTADO ACTUAL
                    posicionInicialMouse = clientX;
                    scrollInicial = scrollWrapper.scrollLeft;
                    anchoInicial = parseFloat(rectanguloRedimensionado.dataset.widthReal);
                    posicionInicialRectRedim = parseFloat(rectanguloRedimensionado.dataset.xReal);
                    ultimaDireccion = direccionInstantanea;
                    ultimoMouseXPantalla = mouseXPantalla;
                    
                    // NO hacer return, continuar con l√≥gica manual
                } else { 
                    // ‚¨ÖÔ∏è Misma direcci√≥n: actualizar y salir
                    ultimoMouseXPantalla = mouseXPantalla;
                    return; 
                }
            } else {
                return;
            }
        } else {
            ultimoMouseXPantalla = mouseXPantalla;
            return;
        }
    }

    // ===============================
    // Modo manual: usar mouseXRelativo (con scroll)
    // ===============================
    const mouseXRelativo = clientX - rectContenedor.left + scrollWrapper.scrollLeft;

    if (ultimoMouseXRelativo !== null) {
        const deltaInstantaneo = mouseXRelativo - ultimoMouseXRelativo;
        if (deltaInstantaneo !== 0)
            ultimaDireccion = Math.sign(deltaInstantaneo);
    }
    ultimoMouseXRelativo = mouseXRelativo;
    ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Actualizar tambi√©n

    // ===============================
    // 2Ô∏è‚É£ Detectar zona de auto-scroll
    // ===============================
    const rectVisual = rectanguloRedimensionado.getBoundingClientRect();

    const rangoBorde = 60;
    const distanciaDerecha = rectContenedor.right - rectVisual.right;
    const distanciaIzquierda = rectVisual.left - rectContenedor.left;

 
//de aqui
const bordeDerechoRect = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                         parseFloat(rectanguloRedimensionado.dataset.widthReal);
const bordeIzquierdoVisible = scrollWrapper.scrollLeft;
const distanciaBordeDerechoAlIzquierdo = bordeDerechoRect - bordeIzquierdoVisible;

if (ladoRedimension === 'derecho' && distanciaBordeDerechoAlIzquierdo <= 60 && ultimaDireccion < 0) {
    console.log('üî¥ Los √∫ltimos 60px del rect√°ngulo est√°n dentro de los 60px del extremo izquierdo');
    
    if (!autoScrollActivo) {
        bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal);  // ‚¨ÖÔ∏è POSICI√ìN IZQUIERDA, NO DERECHA
        autoScrollActivo = true;
        direccionAutoScroll = -1;
        ultimoMouseXPantalla = mouseXPantalla;
        requestAnimationFrame(autoScrollHorizontalContinuoRedim);
    }
    return;
}
const bordeIzquierdoRect = parseFloat(rectanguloRedimensionado.dataset.xReal);
const bordeDerechoVisible = scrollWrapper.scrollLeft + scrollWrapper.clientWidth;
const distanciaBordeIzquierdoAlDerecho = bordeDerechoVisible - bordeIzquierdoRect;

if (ladoRedimension === 'izquierdo' && distanciaBordeIzquierdoAlDerecho <= 60 && ultimaDireccion > 0) {
    console.log('üî¥ Los primeros 60px del rect√°ngulo est√°n dentro de los 60px del extremo derecho');
    
    if (!autoScrollActivo) {
        bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                        parseFloat(rectanguloRedimensionado.dataset.widthReal);  // ‚¨ÖÔ∏è BORDE DERECHO FIJO
        autoScrollActivo = true;
        direccionAutoScroll = 1;  // ‚¨ÖÔ∏è HACIA LA DERECHA
        ultimoMouseXPantalla = mouseXPantalla;
        requestAnimationFrame(autoScrollHorizontalContinuoRedim);
    }
    return;
}
//hasta aqui
 

    if (
        ladoRedimension === 'derecho' &&
        distanciaDerecha <= rangoBorde &&
        ultimaDireccion > 0
    ) {
        if (!autoScrollActivo) {
            bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal);
            autoScrollActivo = true;
            direccionAutoScroll = 1;
            ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Guardar posici√≥n inicial
            requestAnimationFrame(autoScrollHorizontalContinuoRedim);
        }
        return;
    } else if (
        ladoRedimension === 'izquierdo' &&
        distanciaIzquierda <= rangoBorde &&
        ultimaDireccion < 0
    ) {
        if (!autoScrollActivo) {
            bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                            parseFloat(rectanguloRedimensionado.dataset.widthReal);
            autoScrollActivo = true;
            direccionAutoScroll = -1;
            ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Guardar posici√≥n inicial
            requestAnimationFrame(autoScrollHorizontalContinuoRedim);
        }
        return;
    }

    // ===============================
    // 3Ô∏è‚É£ DeltaX (mouse en modo manual)
    // ===============================
    const deltaX = (clientX - posicionInicialMouse) +
                   (scrollWrapper.scrollLeft - scrollInicial);

 
    // ===============================
    // ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è L√ìGICA DE REDIMENSI√ìN MANUAL ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
    // ===============================

    const indice = parseInt(rectanguloRedimensionado.dataset.indice);
    const rectActual = rectangulos[indice];

    if (ladoRedimension === 'derecho') {
        let nuevoAncho = anchoInicial + deltaX;
        nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;
        if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

        const posActual = parseFloat(rectActual.posicion);

        if (nuevoAncho > anchoInicial && indice < rectangulos.length - 1) {
            const rectDerecha = rectangulos[indice + 1];
            const posDerecha = parseFloat(rectDerecha.posicion);

            if (posActual + nuevoAncho >= posDerecha) {
                const desplazamiento =
                    (posActual + nuevoAncho) - posDerecha;
                aplicarEmpujeRedimension(
                    indice + 1,
                    desplazamiento,
                    'derecha'
                );
            }
        }

        rectActual.ancho = nuevoAncho;
        rectActual.elemento.dataset.widthReal = nuevoAncho;

    } else if (ladoRedimension === 'izquierdo') {

    let nuevoAncho = anchoInicial - deltaX;
    nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;
    if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

    let nuevaPosicion = posicionInicialRectRedim + (anchoInicial - nuevoAncho);
    const rectRight = posicionInicialRectRedim + anchoInicial;

    if (indice > 0) {
        const rectPrev = rectangulos[indice - 1];
        const bordeDerechoPrev = parseFloat(rectPrev.posicion) + parseFloat(rectPrev.ancho);

        if (nuevaPosicion < bordeDerechoPrev) {
            // ‚¨ÖÔ∏è HAY COLISI√ìN: EMPUJAR el rect√°ngulo anterior hacia la izquierda
            const desplazamiento = bordeDerechoPrev - nuevaPosicion;
            aplicarEmpujeRedimension(indice - 1, desplazamiento, 'izquierda');
            
            // ‚¨ÖÔ∏è Despu√©s de empujar, el rect√°ngulo anterior se habr√° movido
            // Recalcular su nuevo borde derecho
            const nuevobordeDerechoPrev = parseFloat(rectPrev.posicion) + parseFloat(rectPrev.ancho);
            
            // Si el empuje fue bloqueado (lleg√≥ a PADDING), ajustar nuevaPosicion
            if (nuevobordeDerechoPrev > nuevaPosicion) {
                nuevaPosicion = nuevobordeDerechoPrev;
            }
        }
    } else {
        if (nuevaPosicion < PADDING) nuevaPosicion = PADDING;
    }

    const limiteDerecho = rectRight - SEGMENTO;
    if (nuevaPosicion > limiteDerecho) nuevaPosicion = limiteDerecho;

    nuevaPosicion = Math.round(nuevaPosicion / SEGMENTO) * SEGMENTO;
    nuevoAncho = rectRight - nuevaPosicion;
    
    if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;
    nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;

    rectActual.posicion = nuevaPosicion;
    rectActual.elemento.dataset.xReal = nuevaPosicion;
    rectActual.ancho = nuevoAncho;
    rectActual.elemento.dataset.widthReal = nuevoAncho;
}

    actualizarPosicionesVisuales();
}


function redimensionarRectanguloTouch_00(e) {

    if (!redimensionActiva || !rectanguloRedimensionado) return;

    // ===============================
    // 1Ô∏è‚É£ Posici√≥n del mouse EN LA PANTALLA (sin scroll)
    // ===============================

    let clientX;
    if (e.type.startsWith('touch')) {
        clientX = e.touches[0].clientX; // para touch
    } else {
        clientX = e.clientX; // para mouse
    }

    const rectContenedor = contenedor.getBoundingClientRect(); 
    const mouseXPantalla = clientX - rectContenedor.left; 

    // ‚¨ÖÔ∏è Durante auto-scroll, detectar direcci√≥n usando posici√≥n en pantalla
    if (autoScrollActivo) {
        if (ultimoMouseXPantalla !== null) {
            const deltaInstantaneo = mouseXPantalla - ultimoMouseXPantalla;
            if (deltaInstantaneo !== 0) {
                const direccionInstantanea = Math.sign(deltaInstantaneo);
                
                // Detectar cambio de direcci√≥n opuesta
                if ((direccionAutoScroll === 1 && direccionInstantanea < 0) ||
                    (direccionAutoScroll === -1 && direccionInstantanea > 0)) {
                    
                    // ‚¨ÖÔ∏è CANCELAR AUTO-SCROLL
                    autoScrollActivo = false;
                    direccionAutoScroll = 0;
                    ultimoTimestampAutoScroll = null; 

                    // ‚¨ÖÔ∏è RESETEAR TODO AL ESTADO ACTUAL
                    posicionInicialMouse = clientX;
                    scrollInicial = scrollWrapper.scrollLeft;
                    anchoInicial = parseFloat(rectanguloRedimensionado.dataset.widthReal);
                    posicionInicialRectRedim = parseFloat(rectanguloRedimensionado.dataset.xReal);
                    ultimaDireccion = direccionInstantanea;
                    ultimoMouseXPantalla = mouseXPantalla;
                      
                    // NO hacer return, continuar con l√≥gica manual
                } else {
                    // ‚¨ÖÔ∏è Misma direcci√≥n: actualizar y salir
                    ultimoMouseXPantalla = mouseXPantalla;
                    return;
                }
            } else {
                return;
            }
        } else {
            ultimoMouseXPantalla = mouseXPantalla;
            return;
        }
    }

    // ===============================
    // Modo manual: usar mouseXRelativo (con scroll)
    // ===============================
    const mouseXRelativo = clientX - rectContenedor.left + scrollWrapper.scrollLeft;

    if (ultimoMouseXRelativo !== null) {
        const deltaInstantaneo = mouseXRelativo - ultimoMouseXRelativo;
        if (deltaInstantaneo !== 0)
            ultimaDireccion = Math.sign(deltaInstantaneo);
    }
    ultimoMouseXRelativo = mouseXRelativo;
    ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Actualizar tambi√©n

    // ===============================
    // 2Ô∏è‚É£ Detectar zona de auto-scroll
    // ===============================
    const rectVisual = rectanguloRedimensionado.getBoundingClientRect();
 
    const rangoBorde = 60;
    const distanciaDerecha = rectContenedor.right - rectVisual.right;
    const distanciaIzquierda = rectVisual.left - rectContenedor.left;

//de aqui
const bordeDerechoRect = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                         parseFloat(rectanguloRedimensionado.dataset.widthReal);
const bordeIzquierdoVisible = scrollWrapper.scrollLeft;
const distanciaBordeDerechoAlIzquierdo = bordeDerechoRect - bordeIzquierdoVisible;

if (ladoRedimension === 'derecho' && distanciaBordeDerechoAlIzquierdo <= 60 && ultimaDireccion < 0) {
    console.log('üî¥ Los √∫ltimos 60px del rect√°ngulo est√°n dentro de los 60px del extremo izquierdo');
    
    if (!autoScrollActivo) {
        bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal);  // ‚¨ÖÔ∏è POSICI√ìN IZQUIERDA, NO DERECHA
        autoScrollActivo = true;
        direccionAutoScroll = -1;
        ultimoMouseXPantalla = mouseXPantalla;
        requestAnimationFrame(autoScrollHorizontalContinuoRedim);
    }
    return;
}
const bordeIzquierdoRect = parseFloat(rectanguloRedimensionado.dataset.xReal);
const bordeDerechoVisible = scrollWrapper.scrollLeft + scrollWrapper.clientWidth;
const distanciaBordeIzquierdoAlDerecho = bordeDerechoVisible - bordeIzquierdoRect;

if (ladoRedimension === 'izquierdo' && distanciaBordeIzquierdoAlDerecho <= 60 && ultimaDireccion > 0) {
    console.log('üî¥ Los primeros 60px del rect√°ngulo est√°n dentro de los 60px del extremo derecho');
    
    if (!autoScrollActivo) {
        bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                        parseFloat(rectanguloRedimensionado.dataset.widthReal);  // ‚¨ÖÔ∏è BORDE DERECHO FIJO
        autoScrollActivo = true;
        direccionAutoScroll = 1;  // ‚¨ÖÔ∏è HACIA LA DERECHA
        ultimoMouseXPantalla = mouseXPantalla;
        requestAnimationFrame(autoScrollHorizontalContinuoRedim);
    }
    return;
}
//hsta aqui

    if (
        ladoRedimension === 'derecho' &&
        distanciaDerecha <= rangoBorde &&
        ultimaDireccion > 0
    ) {
        if (!autoScrollActivo) {
            bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal);
            autoScrollActivo = true;
            direccionAutoScroll = 1;
            ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Guardar posici√≥n inicial
            requestAnimationFrame(autoScrollHorizontalContinuoRedim);
        }
        return;
    } else if (
        ladoRedimension === 'izquierdo' &&
        distanciaIzquierda <= rangoBorde &&
        ultimaDireccion < 0
    ) {
        if (!autoScrollActivo) {
            bordeFijoAuto = parseFloat(rectanguloRedimensionado.dataset.xReal) + 
                            parseFloat(rectanguloRedimensionado.dataset.widthReal);
            autoScrollActivo = true;
            direccionAutoScroll = -1;
            ultimoMouseXPantalla = mouseXPantalla; // ‚¨ÖÔ∏è Guardar posici√≥n inicial
            requestAnimationFrame(autoScrollHorizontalContinuoRedim);
        }
        return;
    } 

    // ===============================
    // 3Ô∏è‚É£ DeltaX (mouse en modo manual)
    // ===============================
    const deltaX = (clientX - posicionInicialMouse) +
                   (scrollWrapper.scrollLeft - scrollInicial);

 
    // ===============================
    // ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è L√ìGICA DE REDIMENSI√ìN MANUAL ‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è
    // ===============================

    const indice = parseInt(rectanguloRedimensionado.dataset.indice);
    const rectActual = rectangulos[indice];

    if (ladoRedimension === 'derecho') {
        let nuevoAncho = anchoInicial + deltaX;
        nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;
        if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

        const posActual = parseFloat(rectActual.posicion);
  
        if (nuevoAncho > anchoInicial && indice < rectangulos.length - 1) {
            const rectDerecha = rectangulos[indice + 1];
            const posDerecha = parseFloat(rectDerecha.posicion);

            if (posActual + nuevoAncho >= posDerecha) {
                const desplazamiento =
                    (posActual + nuevoAncho) - posDerecha;
                aplicarEmpujeRedimension(
                    indice + 1,
                    desplazamiento,
                    'derecha'
                );
            }
        }

        rectActual.ancho = nuevoAncho;
        rectActual.elemento.dataset.widthReal = nuevoAncho;

    } else if (ladoRedimension === 'izquierdo') {

        let nuevoAncho = anchoInicial - deltaX;
        nuevoAncho = Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;
        if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;

        let nuevaPosicion =
            posicionInicialRectRedim +
            (anchoInicial - nuevoAncho);

        const rectRight =
            posicionInicialRectRedim + anchoInicial;

        if (indice > 0) {
            const rectPrev = rectangulos[indice - 1];
            const bordeDerechoPrev =
                parseFloat(rectPrev.posicion) +
                parseFloat(rectPrev.ancho);

            if (nuevaPosicion < bordeDerechoPrev) {
                nuevaPosicion = bordeDerechoPrev;
            }
        } else {
            if (nuevaPosicion < PADDING)
                nuevaPosicion = PADDING;
        }

        const limiteDerecho = rectRight - SEGMENTO;
        if (nuevaPosicion > limiteDerecho)
            nuevaPosicion = limiteDerecho;

        nuevaPosicion =
            Math.round(nuevaPosicion / SEGMENTO) * SEGMENTO;

        nuevoAncho = rectRight - nuevaPosicion;
        if (nuevoAncho < SEGMENTO) nuevoAncho = SEGMENTO;
        nuevoAncho =
            Math.round(nuevoAncho / SEGMENTO) * SEGMENTO;

        rectActual.posicion = nuevaPosicion;
        rectActual.elemento.dataset.xReal = nuevaPosicion;
        rectActual.ancho = nuevoAncho;
        rectActual.elemento.dataset.widthReal = nuevoAncho;
    }

    actualizarPosicionesVisuales();
}





function aplicarEmpujeRedimension_2(indiceInicio, desplazamiento, direccion) {
 
    if (direccion === 'derecha') {
        for (let i = indiceInicio; i < rectangulos.length; i++) {
            const rect = rectangulos[i];
            rect.posicion = parseFloat(rect.posicion) + desplazamiento;
            rect.elemento.dataset.xReal = rect.posicion;
        }
    } else if (direccion === 'izquierda') {
        for (let i = indiceInicio; i >= 0; i--) {
            const rect = rectangulos[i];
            const posActual = parseFloat(rect.posicion);
            const nuevaPos = posActual - desplazamiento;
            
            rect.posicion = nuevaPos;
            rect.elemento.dataset.xReal = nuevaPos;
        }
    }
}
 
 


function aplicarEmpujeRedimensionVideoAudio(indiceRedimensionado) {
 
    const rectActual = rectangulos[indiceRedimensionado];
    const posicionActual = parseFloat(rectActual.posicion);
    const anchoActual = parseFloat(rectActual.ancho);

    // Posiciones temporales para calcular empujes
    let posicionesNuevas = rectangulos.map(r => parseFloat(r.posicion));

    // Empujar hacia la derecha los rect√°ngulos siguientes
    for (let i = indiceRedimensionado + 1; i < rectangulos.length; i++) {
        const rectSiguiente = rectangulos[i];
        const anchoPrevio = parseFloat(rectangulos[i - 1].ancho);
        const finPrevio = posicionesNuevas[i - 1] + anchoPrevio;

        if (posicionesNuevas[i] < finPrevio) {
            // Ajustar para que quede justo pegado al anterior
            posicionesNuevas[i] = finPrevio;
        } else {
            break; // No hay solapamiento, se puede detener
        }
    }

    // Empujar hacia la izquierda los rect√°ngulos anteriores
    for (let i = indiceRedimensionado - 1; i >= 0; i--) {
        const rectAnterior = rectangulos[i];
        const anchoActual = parseFloat(rectAnterior.ancho);
        const inicioSiguiente = posicionesNuevas[i + 1];

        if (posicionesNuevas[i] + anchoActual > inicioSiguiente) {
            // Ajustar para que quede justo pegado al siguiente
            posicionesNuevas[i] = inicioSiguiente - anchoActual;
        } else {
            break; // No hay solapamiento
        }
    } 
    // Aplicar las nuevas posiciones
    for (let i = 0; i < rectangulos.length; i++) {
        rectangulos[i].posicion = posicionesNuevas[i]; 
    }

    unica_regla.rectangulos = rectangulos.map(rect => {
                const segundosInicio = (parseFloat(rect.posicion) - PADDING) / SEGMENTO * VALOR_SEGMENTO; 
                const segundosFin = segundosInicio + (parseFloat(rect.ancho) / SEGMENTO * VALOR_SEGMENTO);
	console.log("MAL segundosFin: ",segundosFin);
                return {
                    start: formatearTiempoDecimal(segundosInicio),
                    end: formatearTiempoDecimal(segundosFin),
                    start_value: rect.start_value,
                    end_value: rect.end_value,
		    video_audio_value: rect.video_audio_value
                };
            });

    //importante (relacionado con la redimension del rectangulo despues de definir el segmento de video o audio)
    const json_data_2 =  {"service":"save_item_data","itemName":current_item,"property":current_timeline[2],"params":"empty",     "rectangulos":unica_regla.rectangulos,"extra":"clip"}; 

    websocketClient.send(JSON.stringify(json_data_2)); 
 
}



function aplicarEmpujeRedimension_1(indiceInicio, desplazamiento, direccion) {
 
    if (direccion === 'derecha') {
        for (let i = indiceInicio; i < rectangulos.length; i++) {
            const rect = rectangulos[i];
            rect.posicion = parseFloat(rect.posicion) + desplazamiento;
            rect.elemento.dataset.xReal = rect.posicion;
        }
    } else if (direccion === 'izquierda') {
        for (let i = indiceInicio; i >= 0; i--) {
            const rect = rectangulos[i];
            const posActual = parseFloat(rect.posicion);
            const nuevaPos = posActual - desplazamiento;
            
            if (nuevaPos < PADDING) {
                // ‚¨ÖÔ∏è No se puede mover m√°s a la izquierda
                console.log("üö´ NO SE PUEDE EMPUJAR - Rect√°ngulo en el l√≠mite izquierdo (PADDING)");
                rect.posicion = PADDING;
                rect.elemento.dataset.xReal = PADDING;
 	        // ‚¨ÖÔ∏è DESACTIVAR AUTO-SCROLL
                autoScrollActivo = false;
                direccionAutoScroll = 0;
                ultimoTimestampAutoScroll = null;
		console.log("GRILLA");
    		normalizarAGrilla();
                break;
            } else {
                rect.posicion = nuevaPos;
                rect.elemento.dataset.xReal = nuevaPos;
            }
        }
    }
}

function aplicarEmpujeRedimension(indiceInicio, desplazamiento, direccion) {
 
    if (direccion === 'derecha') {
        for (let i = indiceInicio; i < rectangulos.length; i++) {
            const rect = rectangulos[i];
            rect.posicion = parseFloat(rect.posicion) + desplazamiento;
            rect.elemento.dataset.xReal = rect.posicion;
        }
    } else if (direccion === 'izquierda') {
        // ‚¨ÖÔ∏è PRIMERO: Verificar qu√© rect√°ngulos necesitan moverse (consecutivos)
        const rectangulosAMover = [];
        
        for (let i = indiceInicio; i >= 0; i--) {
            const rect = rectangulos[i];
            rectangulosAMover.push(i);
            
            // Verificar si el siguiente est√° pegado
            if (i > 0) {
                const rectAnterior = rectangulos[i - 1];
                const bordeDerechoAnterior = parseFloat(rectAnterior.posicion) + parseFloat(rectAnterior.ancho);
                const bordeIzquierdoActual = parseFloat(rect.posicion);
                
                // Si NO est√°n pegados, detener
                if (bordeDerechoAnterior < bordeIzquierdoActual) {
                    break;
                }
            }
        }
        
        // ‚¨ÖÔ∏è SEGUNDO: Verificar si ALGUNO llegar√° a PADDING
        let bloqueado = false;
        for (let idx of rectangulosAMover) {
            const rect = rectangulos[idx];
            const nuevaPos = parseFloat(rect.posicion) - desplazamiento;
            if (nuevaPos < PADDING) {
                bloqueado = true;
                break;
            }
        }
        
        // ‚¨ÖÔ∏è TERCERO: Si est√° bloqueado, NO mover ninguno
        if (bloqueado) {
            console.log("üö´ NO SE PUEDE EMPUJAR - Rect√°ngulo en el l√≠mite izquierdo (PADDING)");
            autoScrollActivo = false;
            direccionAutoScroll = 0;
            ultimoTimestampAutoScroll = null;
            console.log("GRILLA");
            normalizarAGrilla();
        } else {
            // ‚¨ÖÔ∏è CUARTO: Si NO est√° bloqueado, mover todos
            for (let idx of rectangulosAMover) {
                const rect = rectangulos[idx];
                const nuevaPos = parseFloat(rect.posicion) - desplazamiento;
                rect.posicion = nuevaPos;
                rect.elemento.dataset.xReal = nuevaPos;
            }
        }
    }
}
 

function aplicarEmpujeRedimension_00(indiceInicio, desplazamiento, direccion) {
 
    if (direccion === 'derecha') {
        for (let i = indiceInicio; i < rectangulos.length; i++) {
            const rect = rectangulos[i];
            rect.posicion = parseFloat(rect.posicion) + desplazamiento;
            rect.elemento.dataset.xReal = rect.posicion;
        }
    } else if (direccion === 'izquierda') {
        for (let i = indiceInicio; i >= 0; i--) {
            const rect = rectangulos[i];
            const nuevaPos = parseFloat(rect.posicion) - desplazamiento;

            if (nuevaPos < PADDING) {
                rect.posicion = PADDING;
                rect.elemento.dataset.xReal = PADDING;
                break;
            } else {
                rect.posicion = nuevaPos;
                rect.elemento.dataset.xReal = nuevaPos;
            }
        }
    }
}

 

function finalizarRedimension() {
    ultimoMouseXPantalla = 0;
    // ===============================
    // üß≤ DETENER AUTO-SCROLL LIMPIO
    // ===============================
    autoScrollActivo = false;
    direccionAutoScroll = 0;
    ultimoTimestampAutoScroll = null;
    console.log("GRILLA");
    normalizarAGrilla();
    // ===============================
    // üîÑ RESETEAR ESTADOS AUTO
    // ===============================
    ultimoMouseXRelativo = null;
    ultimaDireccion = 0;
    bordeFijoAuto = null;
    scrollInicialAuto = null;
    // ===============================
    // üìå REDONDEAR Y CONGELAR ESTADO FINAL
    // ===============================
    if (rectanguloRedimensionado) {
        const indice = parseInt(rectanguloRedimensionado.dataset.indice);
        const rectActual = rectangulos[indice];
        
        // ‚¨ÖÔ∏è REDONDEAR VALORES FINALES A LA CUADR√çCULA
        rectActual.ancho = Math.round(rectActual.ancho / SEGMENTO) * SEGMENTO;
        rectActual.posicion = Math.round(rectActual.posicion / SEGMENTO) * SEGMENTO;
        
        // asegurar que el dataset coincide con el estado final
        rectActual.elemento.dataset.widthReal = rectActual.ancho;
        rectActual.elemento.dataset.xReal = rectActual.posicion;
        
        // ‚¨ÖÔ∏è ACTUALIZAR VISUAL UNA √öLTIMA VEZ CON VALORES REDONDEADOS
        actualizarPosicionesVisuales();
        
        actualizarEstadoGlobal();
        crearBotonMas();
    }
    // ===============================
    // üîì LIMPIAR REDIMENSI√ìN
    // ===============================
    redimensionActiva = false;
    rectanguloRedimensionado = null;
    ladoRedimension = '';
    // ===============================
    // üßπ QUITAR LISTENERS
    // ===============================
    document.removeEventListener('mousemove', redimensionarRectangulo);
    document.removeEventListener('mouseup', finalizarRedimension);
}


 


function finalizarRedimension_orig() {

    autoScrollActivo = false;
    direccionAutoScroll = 0;
    ultimoTimestampAutoScroll = null;
 
    if (rectanguloRedimensionado) {
        actualizarEstadoGlobal();
	console.log("finalizarRedimension: ",finalizarRedimension);
        crearBotonMas();
    }

    redimensionActiva = false;
    rectanguloRedimensionado = null;
    ladoRedimension = '';

    document.removeEventListener('mousemove', redimensionarRectangulo);
    document.removeEventListener('mouseup', finalizarRedimension);
}


function finalizarRedimensionTouch(e) {
    ultimoMouseXPantalla = 0;

    // ===============================
    // üß≤ DETENER AUTO-SCROLL LIMPIO
    // ===============================
    autoScrollActivo = false;
    direccionAutoScroll = 0;
    ultimoTimestampAutoScroll = null;
    console.log("GRILLA");
    normalizarAGrilla();

    // ===============================
    // üîÑ RESETEAR ESTADOS AUTO
    // ===============================
    ultimoMouseXRelativo = null;
    ultimaDireccion = 0;
    bordeFijoAuto = null;
    scrollInicialAuto = null;

    // ===============================
    // üìå REDONDEAR Y CONGELAR ESTADO FINAL
    // ===============================
    if (rectanguloRedimensionado) {
        const indice = parseInt(rectanguloRedimensionado.dataset.indice);
        const rectActual = rectangulos[indice];
        
        // ‚¨ÖÔ∏è REDONDEAR VALORES FINALES A LA CUADR√çCULA
        rectActual.ancho = Math.round(rectActual.ancho / SEGMENTO) * SEGMENTO;
        rectActual.posicion = Math.round(rectActual.posicion / SEGMENTO) * SEGMENTO;
        
        // asegurar que el dataset coincide con el estado final
        rectActual.elemento.dataset.widthReal = rectActual.ancho;
        rectActual.elemento.dataset.xReal = rectActual.posicion;
        
        // ‚¨ÖÔ∏è ACTUALIZAR VISUAL UNA √öLTIMA VEZ CON VALORES REDONDEADOS
        actualizarPosicionesVisuales();
        
        actualizarEstadoGlobal();
        crearBotonMas();
    }

    // ===============================
    // üîì LIMPIAR REDIMENSI√ìN
    // ===============================
    redimensionActiva = false;
    rectanguloRedimensionado = null;
    ladoRedimension = '';

    // ===============================
    // üßπ QUITAR LISTENERS TOUCH
    // ===============================
    document.removeEventListener('touchmove', redimensionarRectanguloTouch);
    document.removeEventListener('touchend', finalizarRedimensionTouch);
}

function finalizarRedimensionTouch_orig() {
    if (rectanguloRedimensionado) {
        actualizarEstadoGlobal();
        console.log("finalizarRedimensionTouch:", finalizarRedimensionTouch);
        crearBotonMas();
    }

    redimensionActiva = false;
    rectanguloRedimensionado = null;
    ladoRedimension = '';

    // Remover los listeners de touch
    document.removeEventListener('touchmove', redimensionarRectangulo);
    document.removeEventListener('touchend', finalizarRedimensionTouch);
}


function actualizarPosicionesVisuales() {
    rectangulos.forEach(rect => {
        rect.elemento.style.left = `${parseFloat(rect.posicion) - offsetVirtual}px`;
        rect.elemento.style.width = `${rect.ancho}px`;
    });

    const boton = document.querySelector('.boton-mas');
    
	if (boton && rectanguloSeleccionado) {
//console.log("BOTON + PRESIONADO");
    		const indiceSeleccionado = parseInt(rectanguloSeleccionado.dataset.indice);
    		const rectSeleccionado = rectangulos[indiceSeleccionado];
    		const posicionBoton = parseFloat(rectSeleccionado.posicion) + parseFloat(rectSeleccionado.ancho);
    		boton.style.left = `${6+posicionBoton - offsetVirtual}px`;//6 es la mitad del ancho del extremo
    		boton.dataset.xReal = posicionBoton;
	}

}

function actualizarEstadoGlobal() {
    unica_regla.selectedTab = current_item;
    unica_regla.rectangulos = rectangulos.map(rect => {
        const segundosInicio = (parseFloat(rect.posicion) - PADDING) / SEGMENTO * VALOR_SEGMENTO;
        const segundosFin = segundosInicio + (parseFloat(rect.ancho) / SEGMENTO * VALOR_SEGMENTO);
console.log("segundosFin: ",segundosFin," ",formatearTiempoDecimal(segundosFin));
        return {
            start: formatearTiempoDecimal(segundosInicio),
            end: formatearTiempoDecimal(segundosFin),
            start_value: rect.start_value,
            end_value: rect.end_value,
	    video_audio_value: rect.video_audio_value
        };
    });

 
 
let current_params = "empty";//time=true 

const json_data =  {"service":"save_item_data","itemName":current_item,"property":unica_regla.selectedProperty,"params":current_params, "rectangulos":unica_regla.rectangulos,"extra":"mal"};

 
/*
	const indice = parseInt(selected_rect.dataset.indice); 
if (indice==3){
	unica_regla.rectangulos[indice].end = "00:00:01.8";
	rectangulos[indice].end = "00:00:01.8"; 
	current_timeline[1]=rectangulos; 
	create_buttons_properties(current_timeline[0]);  
    	inicializar(unica_regla.rectangulos);
	activarBoton(current_property_id);
} 
*/
    //ajustarIntervalosBounce();//reemplazado por ajustarRectangulosMove()
 
 
    websocketClient.send(JSON.stringify(json_data)); 
    console.log('Estado actualizado:', JSON.stringify(unica_regla, null, 2));

     
}

function renderizarElementosVisibles() {
    const scrollLeft = scrollWrapper.scrollLeft;
    //PADDING + TOTAL_PUNTOS * SEGMENTO + PADDING (original)
    const anchoReal = PADDING + TOTAL_PUNTOS * SEGMENTO + PADDING;
    offsetVirtual = Math.max(0, scrollLeft);
    if (offsetVirtual + ANCHO_VENTANA_VIRTUAL > anchoReal) {
        offsetVirtual = Math.max(0, anchoReal - ANCHO_VENTANA_VIRTUAL);
    }
    contenedor.style.transform = `translateX(${offsetVirtual}px)`;

    const minX = offsetVirtual;
    const maxX = offsetVirtual + ANCHO_VENTANA_VIRTUAL;
    const marcadoresVisibles = new Set();
    const labelsVisibles = new Set();
/*  
    todosLosMarcadores.forEach((data, index) => {
        if (data.x >= minX && data.x <= maxX) {
            marcadoresVisibles.add(index);
            if (!marcadoresEnDOM.has(index)) {
                const marcador = document.createElement('div');
                marcador.classList.add('marcador');
		marcador.style.backgroundColor = "rgb(245,245,245)";
                marcador.style.top = `${data.top}px`; //original
        	//marcador.style.top = `${(ALTURA_REGLA * 0.5 / 3 - 16)}px`;//quitar
                marcador.style.height = `${data.height}px`;
                marcador.style.left = `${data.x - offsetVirtual}px`;
                contenedor.appendChild(marcador);
                marcadoresEnDOM.set(index, marcador);
            } else {
                marcadoresEnDOM.get(index).style.left = `${data.x - offsetVirtual}px`;
            }
        }
    });
*/ 

 


 
todosLosMarcadores.forEach((data, index) => {
    if (data.x < minX || data.x > maxX) return; // fuera de rango

    // ‚ú® Saltamos m√∫ltiplos de 5
    if (index % 5 === 0) {
        // Si la bolita exist√≠a previamente en el DOM, la eliminamos
        if (marcadoresEnDOM.has(index)) {
            const marcadorExistente = marcadoresEnDOM.get(index);
            marcadorExistente.remove();
            marcadoresEnDOM.delete(index);
        }
        return;
    }

    // Marcadores visibles normales
    marcadoresVisibles.add(index);

    if (!marcadoresEnDOM.has(index)) {
        const diametro = 3; // di√°metro de la bolita

        const marcador = document.createElement('div');
        marcador.classList.add('marcador');

        marcador.style.width = `${diametro}px`;
        marcador.style.height = `${diametro}px`;
        marcador.style.backgroundColor = "rgb(150,150,150)"; // blanco
        marcador.style.borderRadius = "50%";
        marcador.style.position = "absolute";

        // Centrado vertical
        marcador.style.top = `${(ALTURA_REGLA * 0.5 / 3 + 4) - diametro / 2}px`;
        // Centrado horizontal
        marcador.style.left = `${data.x - offsetVirtual - diametro / 2}px`;

        contenedor.appendChild(marcador);
        marcadoresEnDOM.set(index, marcador);
    } else {
        // Solo movemos la bolita si ya existe
        const marcador = marcadoresEnDOM.get(index);
        const diametro = 3;
        marcador.style.left = `${data.x - offsetVirtual - diametro / 2}px`;
    }
});
 



    todosLosLabels.forEach((data, index) => {
        if (data.x >= minX && data.x <= maxX) {
            labelsVisibles.add(index);
            if (!labelsEnDOM.has(index)) {
                const label = document.createElement('div');
                label.classList.add('label-medicion');
                label.textContent = data.texto;
                label.style.top = `${data.top}px`;
                label.style.left = `${data.x - offsetVirtual}px`;
                contenedor.appendChild(label);
                labelsEnDOM.set(index, label);
            } else {
                labelsEnDOM.get(index).style.left = `${data.x - offsetVirtual}px`;
            }
        }
    });

    marcadoresEnDOM.forEach((elemento, index) => {
        if (!marcadoresVisibles.has(index)) {
            elemento.remove();
            marcadoresEnDOM.delete(index);
        }
    });

    labelsEnDOM.forEach((elemento, index) => {
        if (!labelsVisibles.has(index)) {
            elemento.remove();
            labelsEnDOM.delete(index);
        }
    });

    actualizarPosicionesVisuales();
}

function ajustarScrollWrapper() {
    //PADDING + TOTAL_PUNTOS + PADDING (NUEVO, pero no se sincroniza con el video)		
    //PADDING + TOTAL_PUNTOS * SEGMENTO + PADDING;
    const anchoReal = PADDING + TOTAL_PUNTOS * SEGMENTO + PADDING;
    const scrollContent = document.createElement('div');
    scrollContent.style.width = `${anchoReal}px`;
    scrollContent.style.height = '1px';
    scrollContent.style.position = 'absolute';
    scrollContent.style.top = '0';
    scrollContent.style.left = '0';
    scrollContent.style.pointerEvents = 'none';
    contenedor.appendChild(scrollContent);
}

function cmToPx(cm) {
  const pasos = Math.round(cm / 0.2); 
  return pasos * 40;
}

function setRulerPosition(cm) {
  const custom_x = cmToPx(cm);  // convertimos cm ‚Üí px
  scrollWrapper.scrollLeft = custom_x; // movemos la cinta
}


const time_inicial = formatearTiempoDecimal(24); 
console.log("time_inicial: ",time_inicial);

function inicializar(current_rectangles) {

 

    //document.getElementById('detalles').style.display = "flex";
    crearPseudoRegla();
    crearRegla();
    ajustarScrollWrapper();
 
    resetear(current_rectangles); 
 
    renderizarElementosVisibles();
 
    setRulerPosition(current_scroll_x);

    scrollWrapper.addEventListener('scroll', () => {

const posicion = scrollWrapper.scrollLeft;  
const pasos = Math.floor(posicion / 40);  
const cmExacto = parseFloat((pasos * 0.2).toFixed(1));
current_scroll_x = cmExacto;
const time = formatearTiempoDecimal(parseFloat(cmExacto));
  
 
  console.log("cinta position: ",time, ", ",cmExacto,", ",current_scroll_x);
        setTimeout(renderizarElementosVisibles, 20);
    }, { passive: true });

    	 
         
	document.addEventListener("click", (e) => {
	if (e.target.closest("#modal_overlay_dinamico") ||
      		e.target.closest("#modal_box_dinamico")) {
    		return;
  	}
        if (!e.target.closest("#tab-contents")) {
        	console.log("fuera"); 
		resetOverlay();	
		//show_vertical_line();
	        deseleccionarRectangulo();
		hide_rect_extrems(selected_rect);
        }
	//modal_overlay_dinamico

/*
document.addEventListener('click', (e) => { if ( !e.target.closest('.rectangulo-caja') && !e.target.closest('.boton-mas') && !e.target.closest('.detalles') && !e.target.closest('.contenedor') && !e.target.closest('#tab-contents')  ) { console.log("HOLAA");deseleccionarRectangulo(); } });
*/


	});



}


function finalizar() {
    const contenedor = document.getElementById('contenedor');
    if (contenedor) {
        // Eliminar todo su contenido
        while (contenedor.firstChild) {
            contenedor.removeChild(contenedor.firstChild);
        }
        console.log("Todo el contenido dentro de #contenedor ha sido eliminado.");
    } else {
        console.warn("No se encontr√≥ el elemento con id='contenedor'.");
    }  
}
 
 

function resetear(current_rectangles) {
    // 1Ô∏è‚É£ Limpiar contenedor visual
    if (contenedor) {
        while (contenedor.firstChild) {
            contenedor.removeChild(contenedor.firstChild);
        }
    }

    // 2Ô∏è‚É£ Resetear arrays globales
    rectangulos = []; 
rectangulos.forEach(r => r.elemento.remove());
rectangulos = [];  

console.log("rectangulos rectangulos rectangulos: ",rectangulos);
    todosLosMarcadores = [];
    todosLosLabels = [];
    marcadoresEnDOM.clear();
    labelsEnDOM.clear();

    // 3Ô∏è‚É£ Volver a crear la regla base y los rect√°ngulos
    crearPseudoRegla();
    crearRegla();
    ajustarScrollWrapper();

    // 4Ô∏è‚É£ Cargar nueva data
    unica_regla.rectangulos = current_rectangles;
    unica_regla.rectangulos.forEach((rectData, index) => {
        crearRectangulo(rectData, index);
    });

    // 5Ô∏è‚É£ Re-render
    renderizarElementosVisibles();
}


function reemplazarGuionesEnLista(lista) {
    return lista.map(texto => texto.replace(/_/g, " "));
}
function reemplazarGuionesPorEspacios(texto) {
    return texto.replace(/_/g, " ");
}

function create_buttons_properties(id_buttons) {
	document.getElementById('propiedades_regla').style.display = "flex";
    const container = document.getElementById("propiedades_regla");

    // Limpiar contenido previo
    container.innerHTML = "";

    // Crear los botones a partir del array id_buttons
    id_buttons.forEach(id => {
        const btn = document.createElement("button");
        btn.classList.add("button_property");
        btn.id = id;
	if (id=="item_configuration"){
		btn.textContent = "‚Ä¢‚Ä¢‚Ä¢";
		btn.style.color = "rgb(25, 25, 25)";
		btn.style.backgroundColor = "rgb(196, 205, 208)";
		btn.style.marginRight = "5px";
	}else{
        	btn.textContent = reemplazarGuionesPorEspacios(id); // texto visible del bot√≥n
	}
        container.appendChild(btn);
    });
}
function create_buttons_properties_acumulado(id_buttons) {
    // Asegurarse de que el contenedor est√© visible
    const container = document.getElementById("propiedades_regla");
    container.style.display = "flex";

    // Crear los botones nuevos sin eliminar los existentes
    id_buttons.forEach(id => {
        // Evitar crear botones duplicados por ID
        if (document.getElementById(id)) return;

        const btn = document.createElement("button");
        btn.classList.add("button_property");
        btn.id = id;
        btn.textContent = reemplazarGuionesPorEspacios(id); // texto visible del bot√≥n
        container.appendChild(btn);
    });
}



function create_property_name(property_name) {
    const container = document.getElementById("propiedades_regla");

    // Elimina cualquier p√°rrafo existente con id="nombre_regla" (si ya existe)
    const existingP = container.querySelector("#nombre_regla");
    if (existingP) existingP.remove();

    // Crear el nuevo p√°rrafo
    const p = document.createElement("p");
    p.id = "nombre_regla";
    p.textContent = property_name;

    // Insertar el p√°rrafo al inicio del contenedor
    container.prepend(p);
}

function activarBoton_0(idBoton) {
    console.log("idBoton: ",idBoton);	
    // Selecciona todos los botones dentro del contenedor
    const botones = document.querySelectorAll("#propiedades_regla .button_property");

    // Busca el bot√≥n que coincide con el id
    const botonActivo = document.getElementById(idBoton);

    // Si no existe, salimos sin hacer nada
    if (!botonActivo) {
        console.warn(`No se encontr√≥ ning√∫n bot√≥n con el id: "${idBoton}"`);
        return;
    }

    // Restablece todos los fondos
    botones.forEach(boton => {
        boton.style.backgroundColor = "rgb(124, 85, 230)";
    });

    // Cambia el fondo del bot√≥n activo a negro
    botonActivo.style.backgroundColor = "black";
}

function activarBoton(idBoton) {
    const botones = document.querySelectorAll("#propiedades_regla .button_property");
    const botonActivo = document.getElementById(idBoton);

    if (!botonActivo) return;

    botones.forEach(boton => {
        boton.classList.remove("simulado_activo");
    });

    botonActivo.classList.add("simulado_activo");
}




document.getElementById("propiedades_regla").addEventListener("click", (event) => {
    if (event.target.classList.contains("button_property")) { 
	if (event.target.id === current_property_id) {
            return;
        }
	if (event.target.id == "item_configuration"){
	    console.log("item_configuration");	
	    abrirModalDinamicoSimple(html_item_configuration);	
	    return;	
	}
	current_property_id = event.target.id; 
        console.log("Bot√≥n presionado 2:", event.target.id); 

//actualizar inicio de timeline
let current_params = "time="+current_scroll_x;//time=true 
 
//unica_regla.selectedTab
const json_data_0 =  {"service":"save_item_data","itemName":current_item,"property":unica_regla.selectedProperty,"params":current_params, "rectangulos":unica_regla.rectangulos,"extra":"time"}; 
    //ajustarIntervalosBounce();//mantener comentado
    websocketClient.send(JSON.stringify(json_data_0)); 
 



	const json_data = {"service":"change_item_view","itemName":current_item,"property":event.target.id,"params":"empty","file_type":selectedOption_item,"resolution":resolution_scene,"extra0":"","extra":""}; 
	crear_loading_tab();
	websocketClient.send(JSON.stringify(json_data)); 
	finalizar();
    }
});

let lista_propiedades = ["filename","temperature"];
 
 

function crear_loading_tab(){
	deseleccionarRectangulo();
	const empty_block = document.querySelector(".empty-block");
            if (empty_block) {
                empty_block.style.display = "none";
            }

	const item_loader = document.getElementById("item-loader");
            if (item_loader) {
		console.log("exists");
                item_loader.style.display = "flex";
            }
/*
	const loaderText = document.getElementById('loader-text');
	  if (loaderText) {
	    loaderText.textContent = "Loading item...";
	  } 
*/

}

 
function hide_loading_tab() { 
    const empty_block = document.querySelector(".empty-block");
            if (empty_block) {
                empty_block.style.display = "flex";
            }

	const item_loader = document.getElementById("item-loader");
            if (item_loader) {
		console.log("exists");
                item_loader.style.display = "none";
            }
}

 

 
function obtenerInputsYSelects(htmlString) {//solo funciona si hay 1 solo div principal
    // Crear un contenedor temporal
    const temp = document.createElement("div");
    temp.innerHTML = htmlString.trim();

    // Obtener el div principal
    const rootDiv = temp.firstElementChild;
    if (!rootDiv) return [];

    // Buscar inputs y selects
    const elementos = rootDiv.querySelectorAll("input, select");

    const resultado = [];

    elementos.forEach(el => {
        if (el.id) {
            resultado.push([
                el.id,
                el.tagName.toLowerCase(),   // "input" o "select"
                el.value ?? ""              // valor o string vac√≠o
            ]);
        }
    });

    return resultado;
}


function obtenerInputsYSelects_2(html) { 

    // Obtener el div principal
    const rootDiv = html.firstElementChild;
    if (!rootDiv) return [];

    // Buscar inputs y selects
    const elementos = rootDiv.querySelectorAll("input, select");

    const resultado = [];

    elementos.forEach(el => {
        if (el.id) {
            resultado.push([
                el.id,
                el.tagName.toLowerCase(),   // "input" o "select"
                el.value ?? ""              // valor o string vac√≠o
            ]);
        }
    });

    return resultado;
}


function agregarOptions(htmlString, valores) {
    const temp = document.createElement("div");
    temp.innerHTML = htmlString.trim();

    const select = temp.querySelector("select#selector_dinamico");
    if (!select) return htmlString;

    // Agregar las nuevas opciones sin borrar las existentes
    valores.forEach((val, i) => {
        const option = document.createElement("option");
        option.id = `option_${i}`;
        option.value = val;
        option.textContent = val;
        select.appendChild(option);
    });

    return temp.innerHTML;
}

 
function obtenerIndicesBounce() {
  let indices = [];

  for (let i = 0; i < unica_regla.rectangulos.length; i++) {
    if (unica_regla.rectangulos[i].start_value.includes("/%(bounce)%/")) {
      indices.push(i);
    }
  }

  return indices;
}




function ajustarIntervalosBounce() {

if (!selected_rect) return;
const i = parseInt(selected_rect.dataset.indice); 
console.log("INDEX: ",i);

const list = obtenerIndicesBounce();
console.log("list_2: ",list);
if (!list.includes(i)) return;
 
 
if (!unica_regla.rectangulos[i]) return;
if (!rectangulos[i]) return;
	
 
    const startActual = timeToSeconds(unica_regla.rectangulos[i].start);
    const endActual   = timeToSeconds(unica_regla.rectangulos[i].end);
    const duracion    = endActual - startActual; 
    const endAnterior = timeToSeconds(unica_regla.rectangulos[i - 1].end);

    unica_regla.rectangulos[i].start = formatearTiempoDecimal(endAnterior);
    unica_regla.rectangulos[i].end   = formatearTiempoDecimal(endAnterior + duracion);

    //unica_regla.rectangulos[i].start = "00:00:00.8";
    //unica_regla.rectangulos[i].end   = "00:00:01.0";

/*
        current_timeline[1]=rectangulos; 
	create_buttons_properties(current_timeline[0]);  
    	//inicializar(unica_regla.rectangulos);
	//activarBoton(current_property_id);	
*/
   
 
 

    rectangulos[i].start = formatearTiempoDecimal(endAnterior);
    rectangulos[i].end   = formatearTiempoDecimal(endAnterior + duracion);

    //rectangulos[i].start = "00:00:00.8";
    //rectangulos[i].end   = "00:00:01.0";

        current_timeline[1]=rectangulos; 
	create_buttons_properties(current_timeline[0]);  
    	inicializar(unica_regla.rectangulos);
	activarBoton(current_property_id);	
 
}


 
















 
 








 


 
 

function generarInputsDinamicos(listaDeTitulos, custom_name) {
    let html = `<strong style="width:100%;margin-bottom:10px;">Keyframe 1</strong>`;

    for (const titulo of listaDeTitulos) {
        html += `
            <div id="inputxd" style="display:flex; flex-wrap:wrap; align-items:center; margin-bottom:10px; gap:8px;">
                <strong style="min-width:70px;">${titulo}</strong>
                <input 
                    id="input_${titulo.replace(/\s+/g, '_')}"
                    type="text"
                    data-source="${custom_name}"
                    style="flex:1; min-width:65px; max-width:65px; padding:4px; border-radius:6px;"
                >
            </div>
        `;
    }

    return html;
}
function setInputValues(listaDePares) {
    for (const [titulo, valor] of listaDePares) {
        const id = "input_" + titulo.replace(/\s+/g, '_');
        const input = document.getElementById(id);
        if (!input) continue;
        input.value = valor;
    }
}









 
 

 
 

function generarSelectDinamico() {
  let options = "";

 
const current_files = file_types[current_filetype]; 
for (let i=0;i < current_files.length;i++) { 
    options += `<option value="${current_files[i]}">${current_files[i]}</option>`;
  } 
/*
//los keys son unicos, los de arriba no.
  for (const key in visible_names) { 
    options += `<option value="${key}">${key}</option>`;
  } 
*/

  return `  
    <select id="selector_dinamico" class="dropdown_selector" style="
      width:100%;
      padding:10px 12px;
      font-size:14px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.7);
      background:linear-gradient(180deg, rgba(255,255,255,0.95) 0%, rgba(210,240,255,0.9) 50%, rgba(180,220,255,0.95) 100%);
      box-shadow:0 2px 6px rgba(0,0,0,0.25), inset 0 1px 2px rgba(255,255,255,0.8);
      backdrop-filter:blur(4px);
      appearance:none;
      cursor:pointer;
    ">
      <option disabled selected>Select file</option>
      ${options}
    </select>
  `;
}
 
function setOption(optionKey) { 
    const select = document.getElementById("selector_dinamico");
    if (!select) return;

    // Buscar la opci√≥n por su valor (que es el key)
    const optionToSelect = select.querySelector(`option[value="${optionKey}"]`);
    if (!optionToSelect) return;

    // Cambiar la selecci√≥n
    select.value = optionKey;

    // Disparar manualmente el evento "change" por si tienes listeners
    select.dispatchEvent(new Event("change"));
}

document.addEventListener("change", function(e) {
    if (e.target.matches("#selector_dinamico")) {
	const valor = e.target.value;
	const indice = parseInt(selected_rect.dataset.indice);
	unica_regla.rectangulos[indice].start_value = valor;
            rectangulos[indice].start_value = valor;  

	unica_regla.rectangulos[indice].end_value = valor;
            rectangulos[indice].end_value = valor;
            actualizarEstadoGlobal();
        console.log("Key seleccionado:", e.target.value);
        if (valor in visible_names) {
		console.log("VISIBLE NAMES: ",valor);
  		filenames_llenos=filenames_llenos+1;
	}
	//filenames_llenos=filenames_llenos+1;

	//agregarBotonInterval();
	if (valor!=""){
		const div_interval = document.getElementById("btn_select_interval");
		if (div_interval && current_filetype=="video"){ 
			div_interval.style.display = "block";
		}
		if (div_interval && current_filetype=="audio"){ 
			div_interval.style.display = "block";
		}
	}
    }
});
 









 

function agregarBotonInterval() {
  const selector = document.getElementById("selector_dinamico");
  if (!selector) return;

  const boton = document.createElement("button");
  boton.id = "btn_select_interval";
  boton.textContent = "Select interval";

  // Estilo inline tipo Frutiger Aero
  boton.style.display = "block";
  boton.style.marginTop = "12px";
  boton.style.padding = "10px 18px";
  boton.style.fontSize = "14px";
  boton.style.borderRadius = "10px";
  boton.style.border = "1px solid rgba(255,255,255,0.7)";
  boton.style.background = "linear-gradient(180deg, rgba(255,255,255,0.9) 0%, rgba(210,240,255,0.85) 45%, rgba(180,220,255,0.9) 100%)";
  boton.style.boxShadow = "0 2px 6px rgba(0,0,0,0.25), inset 0 1px 2px rgba(255,255,255,0.8)";
  boton.style.backdropFilter = "blur(4px)";
  boton.style.cursor = "pointer";

  selector.insertAdjacentElement("afterend", boton);
}


//pendiente
//agregarBotonInterval();


function setSpeedActiveInBox(box, speed) {
  if (!box) return;

  console.log("speed BOX:", speed);

  [...box.querySelectorAll('.videoClipperSpeedOptionButton')].forEach(btn => {
    const isActive = btn.dataset.speed === speed;

    // activar clase
    btn.classList.toggle('videoClipperSpeedActive', isActive);

    // aplicar estilos seg√∫n activo o no
    if (isActive) {
      btn.style.backgroundColor = "#7c55e6";
      btn.style.color = "white";
      btn.style.border = "1px solid #7c55e6";
    } else {
      btn.style.backgroundColor = "transparent";
      btn.style.color = ""; // color por defecto
      btn.style.border = "1px solid #999";
    }
  });
}


function setSpeed(box){
  const index = parseInt(selected_rect.dataset.indice);  
  const video_params = unica_regla.rectangulos[index].video_audio_value; 
  console.log("video_params video_params:",video_params);
  let speed = 1; 
  if (video_params!=""){ 
        speed = parseFloat(video_params.split(",")[2]);
	console.log("speed speed:",speed);
	const speed_string = video_params.split(",")[2].toString();
	setSpeedActiveInBox(box, speed_string);  

  }	
}



function abrirModalDinamico(htmlString,sub_property) {

  hide_vertical_line();

  const box = document.getElementById('modal_box_dinamico');
  box.innerHTML = htmlString; // Insertar HTML din√°mico
  setSpeed(box);
  document.getElementById('modal_overlay_dinamico').style.display = 'flex';
 

  console.log("current_timeline[2]: ",current_timeline[2]);

  const indice = parseInt(selected_rect.dataset.indice); 
  const detalle = unica_regla.rectangulos[indice]; 
  let current_property_value = detalle.start_value;

  const firstDiv = box.querySelector("div");
  console.log("firstDiv.className: ",firstDiv.className);	
  if (firstDiv.className == "end_type"){
   	current_property_value = detalle.end_value;
  }
 
  
  const list_values = current_property_value.split(",");

  const lista_inputs_and_selects = obtenerInputsYSelects(htmlString);
  console.log("lista_inputs_and_selects: ",lista_inputs_and_selects);

  for (let i = 0; i < lista_inputs_and_selects.length; i++) {
    let id = lista_inputs_and_selects[i][0];
    let tipo = lista_inputs_and_selects[i][1];
    console.log(id, tipo);
    const elem = document.getElementById(id);
    if (elem) {
	console.log("htmlString: ",htmlString); 
	if (list_values[i]!=""){ 
	   if (tipo=="input"){	
        	elem.value = list_values[i];
		if (current_property_value==""){
			elem.value = "";
		}
	   }else{ 
		console.log("9000: ",list_values[i],"current_filetype:",current_filetype);
		for (let opt of elem.options) {
			console.log("opt: ",opt);
		    if (opt.value === list_values[i]) {
		      elem.value = list_values[i];
			if (list_values[i]){
				const div_interval = document.getElementById("btn_select_interval");
				if (div_interval && current_filetype=="video"){ 
					div_interval.style.display = "block";
				}
				if (div_interval && current_filetype=="audio"){ 
					div_interval.style.display = "block";
				}
			}
		      break;
		    }
	        }
	   }	
	}
    }
  }

  
   
 

} 




function abrirModalDinamicoSimple(htmlString) {

  hide_vertical_line();

  const box = document.getElementById('modal_box_dinamico');
  box.innerHTML = htmlString; // Insertar HTML din√°mico
  document.getElementById('modal_overlay_dinamico').style.display = 'flex';
 
} 
  

function eliminarTabPorNombre_0(tabName) {
  const container = document.getElementById('tabs-scroll-container');
  if (!container) return;

  const tab = container.querySelector(`[data-tab-name="${tabName}"]`);
  if (tab) {
	const json_data =  {"service":"de4lete_item","item_to_delete":current_item,"extra":"de4lete_item"}; 
	websocketClient.send(JSON.stringify(json_data)); 
        tab.remove();
  }
}


function reset_variables(){

    offsetVirtual = 0;
    marcadoresEnDOM = new Map();
    labelsEnDOM = new Map();
    todosLosMarcadores = [];
    todosLosLabels = [];
    rectangulos = [];

    arrastreActivo = false;
    rectanguloArrastrado = null;
    offsetInicialX = 0;
    posicionInicialRect = 0;

    redimensionActiva = false;
    rectanguloRedimensionado = null;
    ladoRedimension = '';
    posicionInicialMouse = 0;
    anchoInicial = 0;
    posicionInicialRectRedim = 0;
    rectanguloSeleccionado = null;

    filenames_llenos = 0;
    textnames_llenos = 0;
    current_item = "scene";
    current_property_id = "";
    customNames = ["scene"]; 
     
/*
    uploadedFiles = {};
    file_types = {
            "image": [],
            "video": [],
            "audio": [],
	    "text": []	
        };
 
    item_types = {
            "image": [],
            "video": [],
            "audio": []
        };
*/
}


function request_new_project(){

    reset_variables(); 

    //resolution_scene = "1280x720";
    console.log("eliminar todos los tabs y vaciar archivos subidos");
    closeModalDinamico();
    const json_data =  {"service":"new_project","resolution":resolution_scene,"itemName":current_item,"property":event.target.id,"params":"empty","file_type":selectedOption_item,"extra0":"","extra":""}; 
    websocketClient.send(JSON.stringify(json_data)); 
 
    const container = document.getElementById('tabs-scroll-container');
    if (!container) return; 
    const tabs = container.querySelectorAll('[data-tab-name]');
 
    const nombreAnterior = "scene";
    const tab = document.querySelector(`.tab[data-tab-name="${nombreAnterior}"]`);
    tab.dataset.modo = "delete_item";//si quito esto se ejecuta el save_item del cursor y eso modifica el valor de filename
    tab.click();

    // Elimina todos los tabs
    tabs.forEach(tab => {
      if (tab.dataset.tabName !== 'scene') {
        tab.remove();
      }
    });
 
 
}
 
function eliminarTabPorNombre(tabName) {
  const container = document.getElementById('tabs-scroll-container');
  if (!container) return;

  const tabActual = container.querySelector(`[data-tab-name="${tabName}"]`);
  if (!tabActual) return;

  const tabAnterior = tabActual.previousElementSibling;

  // Si no hay tab arriba, no se elimina nada
  if (!tabAnterior || !tabAnterior.hasAttribute('data-tab-name')) {
    console.log('No hay tab anterior, no se elimina');
    return;
  }

  customNames = customNames.filter(name => name !== current_item);

  // Imprime el data-tab-name del de arriba
  const nombreAnterior = tabAnterior.getAttribute('data-tab-name');
  console.log('Tab anterior:', nombreAnterior);

  //const json_data =  {"service":"delete_item","item_to_delete":current_item,"extra":"1","extra2":"2"}; 
  const json_data = {"service":"delete_item","item_to_delete":current_item,"itemName":current_item,"property":event.target.id,"params":"empty","file_type":selectedOption_item,"extra0":"","extra":""}; 

  websocketClient.send(JSON.stringify(json_data)); 

  const tab = document.querySelector(`.tab[data-tab-name="${nombreAnterior}"]`);
  tab.dataset.modo = "delete_item";//si quito esto se ejecuta el save_item del cursor y eso modifica el valor de filename
  tab.click(); 
   
  // Elimina el tab actual
  tabActual.remove();
}


 


document.addEventListener("click", function (e) {
    if (e.target.matches("#delete_item")){
	console.log("delete_item presionado");
	eliminarTabPorNombre(current_item);
	closeModalDinamico();
    } 

    if (e.target.matches("#log_in")){
	console.log("log_in");
	abrirModalDinamicoSimple(html_log_in);
    } 
    if (e.target.matches("#saved_projects")){
	abrirModalDinamicoSimple(html_saved_projects);
    }
    if (e.target.matches("#video_tutorials")){
	abrirModalDinamicoSimple(html_video_tutorials);
    }
    if (e.target.matches("#upgrade_plan")){
	abrirModalDinamicoSimple(html_upgrade_plan);
    }

    if (e.target.matches("#update_video")){
	request_render();
    }

    if (e.target.matches("#create_new_project")){
	request_new_project();
    }

     
 
 
     	
    if (e.target.matches("#modal_overlay_dinamico")) {
	show_vertical_line();
        e.target.style.display = "none"; 
	closeModalDinamico();
	console.log("‚úÖ‚úÖ‚úÖ‚úÖ "+timestamp_and_duration+","+current_speed, " ",rectangulos);
	console.log("unica_regla.rectangulos[0].video_audio_value: ",rectangulos[0].video_audio_value);

	const box = document.getElementById('modal_box_dinamico');
	const divPrincipal = box.querySelector("div");
	console.log("‚úÖdivPrincipal.className: ",divPrincipal.className);  // id del div principal

	const lista_inputs_and_selects = obtenerInputsYSelects_2(box);
  	console.log("lista_inputs_and_selects: ",lista_inputs_and_selects);

	let inputs_combined = "";
  	for (let i = 0; i < lista_inputs_and_selects.length; i++) {
    		let id = lista_inputs_and_selects[i][0];
    		let value = lista_inputs_and_selects[i][2];
		value = limpiarEspacios(value);
		if (id=="input_dynamic_box_0"){
		    if (value!=""){
			console.log("TEXNAME: ",value);
                        if (current_filetype=="text"){
				textnames_llenos = textnames_llenos + 1;
			}  
		    } 	
		}
    		console.log("save: ",id, value); 
		inputs_combined=inputs_combined+value;
		if (i<lista_inputs_and_selects.length-1){
			inputs_combined=inputs_combined+",";
		}
  	}

	if (divPrincipal.className == "start_type"){  
        	console.log("COMBINED =", inputs_combined);  
        	const valor = inputs_combined;
		const indice = parseInt(selected_rect.dataset.indice);
		/*
		if (unica_regla.rectangulos[indice].start_value.includes("/%(bounce)%/")){
			unica_regla.rectangulos[indice].start_value = valor+",/%(bounce)%/";
			rectangulos[indice].start_value = valor+",/%(bounce)%/";
		}else{
			unica_regla.rectangulos[indice].start_value = valor;
			rectangulos[indice].start_value = valor;
		}*/
		unica_regla.rectangulos[indice].start_value = valor;
        	rectangulos[indice].start_value = valor;  
        	actualizarEstadoGlobal();
  	}
	if (divPrincipal.className == "end_type"){  
        	console.log("COMBINED =", inputs_combined);  
        	const valor = inputs_combined;
		const indice = parseInt(selected_rect.dataset.indice);
		unica_regla.rectangulos[indice].end_value = valor;
        	rectangulos[indice].end_value = valor;  
        	actualizarEstadoGlobal();
  	}
	if (divPrincipal.className == "start_end_type"){  
		console.log("COMBINED =", inputs_combined);  
        	const valor = inputs_combined;
		const indice = parseInt(selected_rect.dataset.indice);

		if (unica_regla.rectangulos[indice].start_value.includes("/%(bounce)%/")){
			unica_regla.rectangulos[indice].start_value = valor+",/%(bounce)%/";
        		rectangulos[indice].start_value = valor+",/%(bounce)%/";  
		
			unica_regla.rectangulos[indice].end_value = valor+",/%(bounce)%/";
        		rectangulos[indice].end_value = valor+",/%(bounce)%/";  	 
		}else{
			unica_regla.rectangulos[indice].start_value = valor;
        		rectangulos[indice].start_value = valor;  
		
			unica_regla.rectangulos[indice].end_value = valor;
        		rectangulos[indice].end_value = valor;  
		}
		/*
		unica_regla.rectangulos[indice].start_value = valor;
        	rectangulos[indice].start_value = valor;  
		
		unica_regla.rectangulos[indice].end_value = valor;
        	rectangulos[indice].end_value = valor;*/  

        	actualizarEstadoGlobal();
	}
	 
    }
});


 

 
 




 
document.addEventListener("click", (e) => {
    // Filtra solo si se hace click en el bot√≥n con id "btn_select_interval"
    const btn = e.target.closest("#btn_select_interval");
    if (!btn) return; // si no es ese bot√≥n, salir

    document.getElementById('modal_overlay_dinamico').style.display = 'none'; 
    const select = document.getElementById("selector_dinamico");
    if (select){	
    	const valor_seleccionado = select.value; 
    	console.log("valor_seleccionado interval: ",valor_seleccionado,unica_regla.rectangulos);
    	current_filename = valor_seleccionado;
        
        const url_object = filename_url[valor_seleccionado];
	console.log("error audio:",valor_seleccionado,", url: ",url_object);
    	abrirModalConClipper(url_object);
    }
});

 

// Delegaci√≥n de eventos para todos los botones
const grupo = document.getElementById("grupo-botones");
grupo.addEventListener("click", (e) => {
 
    const btn = e.target.closest("button");
    if (!btn) return; // clic no en bot√≥n 
    const nombre_id = btn.id;

    if (!nombre_id) return; 
 
    if (nombre_id === "Delete_box") { 
 
	resetOverlay();
	const indice = parseInt(selected_rect.dataset.indice);

        if (unica_regla.rectangulos.length <= 1) {
            //alert('No se puede eliminar el √∫ltimo rect√°ngulo.');
	    showErrorModal('The last rectangle cannot be deleted.');
            return;
        }else{
	   if(unica_regla.rectangulos.length==2 && indice<unica_regla.rectangulos.length-1){
		if ( rectangulos[indice+1] && typeof rectangulos[indice+1].start_value === "string" && rectangulos[indice+1].start_value.includes("/%(bounce)%/")){
			//alert('No se puede eliminar el √∫ltimo rect√°ngulo');
			showErrorModal('The last rectangle cannot be deleted.');
            		return;
		}
	   }
	}

        // 1Ô∏è‚É£ Eliminar del array local
        rectangulos[indice].elemento.remove();
        rectangulos.splice(indice, 1);

        // 2Ô∏è‚É£ Eliminar del JSON principal
        unica_regla.rectangulos.splice(indice, 1); 

        // 3Ô∏è‚É£ Reindexar dataset.indice de los rect√°ngulos restantes
        rectangulos.forEach((r, i) => {
            r.elemento.dataset.indice = i;
        });


	// üîÅ L√ìGICA EXTRA (DESPU√âS, SIN TOCAR NADA ARRIBA)
//eliminar el box del bounce asociado
if (
    rectangulos[indice] &&
    typeof rectangulos[indice].start_value === "string" &&
    rectangulos[indice].start_value.includes("/%(bounce)%/")
) {
    rectangulos[indice].elemento.remove();
    rectangulos.splice(indice, 1);
    unica_regla.rectangulos.splice(indice, 1);

    // reindexar otra vez porque volvi√≥ a cambiar
    rectangulos.forEach((r, i) => {
        r.elemento.dataset.indice = i;
    });
}

        // 4Ô∏è‚É£ Limpiar los detalles
        deseleccionarRectangulo();

        // 5Ô∏è‚É£ Renderizar nuevamente
        renderizarElementosVisibles();

        actualizarEstadoGlobal();

    }else{
	console.log("000: ",current_filetype);
	if (dic_dynamic_options?.[current_filetype]?.[current_property_id]?.[nombre_id]){
		let current_modal_html = dic_dynamic_options[current_filetype][current_property_id][nombre_id];
		if (current_filetype!="text" && current_property_id=="filename"){
			const current_files = file_types[current_filetype]; 
			//visible_names (alternativa pero no filtra por tipo de file)
			current_modal_html = agregarOptions(current_modal_html,current_files);
		}
		abrirModalDinamico(current_modal_html,nombre_id);
	}else{
		if (nombre_id=="bounce"){
			console.log("BOTON PRESIONADO BOUNCE");
			crear_bounce_rectangle();
		}else{
		const current_modal_html = dic_dynamic_options["general"];
		abrirModalDinamico(current_modal_html,nombre_id); 
		}
	}
    }	
 

    	  	
});
 
function hide_vertical_line(){
const overlay_regla = document.getElementById("overlay_regla");
if (overlay_regla){
	overlay_regla.style.display="none";
}
}
function show_vertical_line(){
const overlay_regla = document.getElementById("overlay_regla");
if (overlay_regla){
	overlay_regla.style.display="block";
}
}

function generarBotones(listaOpciones) { 
//hide_vertical_line();
    const contenedor = document.getElementById("botones-alineados");
    const grupo = document.getElementById("grupo-botones");
    const botones = grupo.querySelectorAll("button");

    const maxButtonWidth = 100;
    const minButtonWidth = 60;
    const total = listaOpciones.length;
    const anchoContenedor = contenedor.clientWidth;
    let anchoBoton;

    if (total <= 4) {
        anchoBoton = anchoContenedor / total;
        anchoBoton = Math.min(maxButtonWidth, Math.max(minButtonWidth, anchoBoton));
        contenedor.style.overflowX = "hidden";
    } else {
        anchoBoton = anchoContenedor / 4.5;
        anchoBoton = Math.min(maxButtonWidth, Math.max(minButtonWidth, anchoBoton));
        contenedor.style.overflowX = "auto";
    }

    // Limpiar botones visibles
    botones.forEach(btn => {
        btn.style.display = "none";
        btn.style.width = "";
        btn.style.backgroundColor = "";
    });

    // Asignar nombres visibles y color
    listaOpciones.forEach((nombre_id, i) => {//nombreVisible
	const nombreVisible = reemplazarGuionesPorEspacios(nombre_id);

        if (i >= botones.length) return;

        const btn = botones[i];
        btn.textContent = nombreVisible;
        btn.style.width = anchoBoton + "px";

        // Color por defecto
        let color = "rgb(196, 205, 208)";//#02f57c
 
        if (nombreVisible === "Delete box") {
            color = "#e23445";//#e23445  
	    btn.style.textShadow = "1px 2px 4px rgba(0,0,0)";
	    btn.style.fontWeight = "bold"; 
        }else{
		btn.style.color = "rgb(25,27,35)";
		btn.style.textShadow = "none"; 
		btn.style.fontWeight = "bold";
	}
	if (nombreVisible === "bounce parameters") {
		color = "rgb(255, 249, 105)";//yellow  
		btn.style.minWidth = "150px"; 
	}else{
		btn.style.minWidth = "80px"; 
	}
	btn.style.height = "auto";//quitar  
        btn.style.backgroundColor = color;
        btn.style.display = "inline-block";
        //btn.id = `property_option_${i}`;
	btn.id = nombre_id;
    });

    grupo.style.justifyContent = total <= 4 ? "center" : "flex-start";
}


window.addEventListener("resize", () => {
    generarBotones(box_options);  
});


 


 


 
function actualizarRectangulo(indice, rectNuevo) { 
    if (!unica_regla.rectangulos[indice]) return; // evita errores

    unica_regla.rectangulos[indice].start = rectNuevo.start;
    unica_regla.rectangulos[indice].end   = rectNuevo.end;
}






const array_real = [10,20,30];




crear_loading_tab();


let reconnectTimeout = null;
let isReconnecting = false;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 100;
 
function connect(type_connection) {


  if (websocketClient) {
    websocketClient.close();
    websocketClient = null;
  }

  if (reconnectTimeout) {
    clearTimeout(reconnectTimeout);
    reconnectTimeout = null;
  }

  isReconnecting = false; 


  const user_id = userId;
  const currentPath = "/path";
  const url_websocket = "rndomg84pbrg.onrender.com"; 
  websocketClient = new WebSocket("wss://" + url_websocket + "/" + user_id);
  websocketClient.binaryType = "arraybuffer";

  console.log("connecting..."); 

 
 

  websocketClient.addEventListener("open", () => {

    reconnectAttempts = 0;   // <-- AQU√ç S√ç
    isReconnecting = false;

    console.log("Client connected"); 
	
    hide_loading_tab();
    createTab("scene");
     
    const send_type_connection =
      "type_connection==" +
      type_connection +
      "==" +
      currentPath +
      "==" +
      user_id;
    websocketClient.send(send_type_connection);

 

  });

  websocketClient.addEventListener("message", (event) => {
    let message_result = event.data;

    if (typeof message_result === "string") {
      console.log("MENSAJE: ",message_result);
      if (message_result.startsWith("{") && message_result.endsWith("}")) {
        const data = JSON.parse(message_result);
	const service = data["service"];

	if (service=="change_item_view" || service=="max_duration"){ //|| service=="max_duration"

	 
console.log("‚úî‚úî‚úî‚úî‚úî",rectangulos[0]);
 
	 
 

	resetOverlay();	
	 
         
	const list_params = data["params"].split("&");
        current_scroll_x = 0;
	if (list_params.length>0){
		for (let i=0;i<list_params.length;i++){
			if (list_params[i].split("=")[0]=="time"){
				current_scroll_x = parseFloat(list_params[i].split("=")[1]);
				break;
			}
		}
	}
        console.log("&&&&current_scroll_x: ",data["params"],", ",current_scroll_x);

	const item_name = data["itemName"]; 
	current_filetype = data["fileType"];

	if (item_types[current_filetype]){
	    if (!item_types[current_filetype].includes(item_name)){
		item_types[current_filetype].push(item_name);	
	    }
	}
	console.log("item_types: ",item_types);

	let property_id = data["property"];
	box_options = data["boxOptions"];
	current_box_options = box_options;
        console.log("PROPERTY: ",property_id);
	if (property_id=="timestamp_of_video_item"){
	    property_id = "filename";
	}
	const current_rectangles = data["rectangulos"];  
	const property_name = reemplazarGuionesPorEspacios(property_id);
	 
	const lista_propiedades = data["properties"];

	unica_regla.selectedProperty = property_id; 
	hide_loading_tab();
        document.querySelector('.empty-block').style.display = "flex"; 

	 
	create_buttons_properties(lista_propiedades); 
	console.log("lista_propiedades: ",lista_propiedades); 
    	inicializar(current_rectangles);  
	activarBoton(property_id);  
	 
	current_timeline[0] = lista_propiedades;
	current_timeline[1] = current_rectangles;
        //rectangulos = current_rectangles;//pendiente de revisar
	current_timeline[2] = property_id; 
	current_timeline[3] = item_name; 
	current_property_id = property_id; 
	current_item = item_name;
console.log("MAL: ",current_item);

//unica_regla.rectangulos = current_rectangles;
 
 
  	console.log("REAL VALUE: ",array_real[0]);
	
	console.log("‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖcurrent_rectanglessss: ",current_rectangles," ",unica_regla.rectangulos );

 
create_panel_tab(current_item+"_"+current_property_id);
open_panel_tab(current_item+"_"+current_property_id);
  
	}
 
	 
 
 
      }

    if (message_result === "ready_to_upload") {
      console.log("‚úÖ Servidor listo para recibir el archivo...");
      sendFile(currentFile);
    }

    if (false && message_result.includes("last_item_modified")){ 
	const data = JSON.parse(message_result); 
	console.log("last_item_modified: ",message_result);
	const last_item_modified = data["last_item_modified"].replace(/@/g, "");
 
const tab = document.querySelector(`.tab[data-tab-name="${last_item_modified}"]`);
tab.click();
 
    }

 

if (message_result === "all_chunks_received") {
  console.log("‚úÖ Subida completa:", currentFile.name);

  // Quita el porcentaje: normaliza el value de progress_visible_names al key
  const baseName = currentFile.name.replace(/\.[^/.]+$/, "");
  const extension = currentFile.name.match(/\.[^/.]+$/)?.[0] || "";

  const currentKey = Object.keys(progress_visible_names).find(k =>
    k.startsWith(baseName) && k.endsWith(extension)
  );

  if (currentKey) {
    progress_visible_names[currentKey] = currentKey; // value id√©ntico al key
    console.log("progress_visible_names:", progress_visible_names); 
  }

  // A√±ade a la lista de subidos (visible_names sigue igual que antes)
  const visibleKey = Object.keys(visible_names).find(k =>
    k.includes(baseName) && k.endsWith(extension)
  );
  if (visibleKey) uploaded_names.push(visibleKey);

  if (Object.keys(progress_visible_names).length === uploaded_names.length){
	console.log("activar boton de renderizado"); 
	//ocultar error_subidas_pendientes y pendientes_de_subir
	ocultarPendientesYErrores();
  }

  isUploading = false;
  currentFile = null;

  // Procesa el siguiente archivo en cola
  processNextUpload();
}









    }else{



if (event.data instanceof ArrayBuffer) {
  const bytes = new Uint8Array(event.data);

 


  let firstInt =
    bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);

 

  if (firstInt < 0) {
    const secondInt = (bytes[4] << 24) >> 24;

    if (secondInt >= 0) {
      type_video = "video/webm";
      video_extension = ".webm";
    } else {
      type_video = "video/mp4";
      video_extension = ".mp4";
    }

    if (globalBuffer.length == 0) {
      //destroyCancelButton();
    }

console.log("chunk: ", globalBuffer.length," ",Math.abs(firstInt));

     
    const subBuffer = bytes.subarray(5);
    suma_final = suma_final + subBuffer.byteLength;
    const newBuffer = new Uint8Array(globalBuffer.length + subBuffer.length);
    newBuffer.set(globalBuffer, 0);
    newBuffer.set(subBuffer, globalBuffer.length);

    globalBuffer = newBuffer;

    if (video_tag == "webm") {
      const current_load = [
        [globalBuffer.length, Math.abs(firstInt), "#0000FF"],
      ];
      generarBarras(current_load);
    } else {
      const current_load = [
        [
          globalBuffer.length,
          Math.abs(firstInt),
          "percentage",
          "#0000FF",
          "Preparing video . . .",
        ],
      ];
      draw_percentage(current_load);
    }

    if (globalBuffer.length == Math.abs(firstInt)) {
      console.log("FULL_VIDEO_RECEIVED");
      ocultarBarras();
      frameIndex = 0;
      n_seg = 0;
      watch(); 
      show_videoTag();
      show_vertical_line();	
      websocketClient.send("full_video_received_" + video_tag);
      const error_connection_2 = document.querySelector(".error-creation-2");
      if (error_connection_2) {
        error_connection_2.innerText = "Video rendered successfully";
        error_connection_2.style.display = "block";
      }
    }
  } else {
    const duracion_video = firstInt;
    const secondInt = (bytes[4] << 24) >> 24;
 
    if (secondInt > 0) {
      if (frameIndex == 0) {
	console.log("frameIndex: ", frameIndex);
        close_loading();
        if (duracion_video >= 0) {
          //createCancelButton();
        }
      }

      const current_load = [[n_seg, duracion_video, "#4caf50"]];
      generarBarras(current_load);
      const percentage = n_seg / duracion_video;
      if (percentage > 0.6) {
        //destroyCancelButton();
      }

      const chunk_data = bytes.subarray(5);
      const frames = getChunks(chunk_data);

console.log("chunk: ", frames.length); 

      feedFrames(frames, current_fps);
      if (current_fps < 17 && n_seg % 8 == 0) {
        current_fps = current_fps + 1;
      }
    } else {
      const current_load = [
        [n_seg, duracion_video, "time", "#4caf50", "Rendering video . . ."],
      ];
      draw_percentage(current_load);
      if (Math.abs(n_seg - duracion_video) <= 2) {
        clearCircle();
      }
    }
    n_seg = n_seg + 1;
  }
}



}

  });

 

  websocketClient.addEventListener("close", (event) => {  
 
        scheduleReconnect();
 
  });

  websocketClient.addEventListener("error", (error) => { 
        
	scheduleReconnect();
  });
}

function scheduleReconnect() {

  hide_loading_tab();
  crear_loading_tab();

  if (isReconnecting) return;
  isReconnecting = true;
 
  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
    console.warn("L√≠mite de reconexiones alcanzado");
    return;
  }

  reconnectAttempts++; 

  frameIndex = 0;
  globalBuffer = new Uint8Array(0);
  ocultarBarras();
  n_seg = 0;

  console.log(`Reintentando conexi√≥n (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}) en 5s...`);

  reconnectTimeout = setTimeout(() => {
    connect("reconnecting");
  }, 5000);
}


function scheduleReconnect_0() {

  if (isReconnecting) return;
  isReconnecting = true;

  frameIndex = 0;
  globalBuffer = new Uint8Array(0);
  ocultarBarras();
  n_seg = 0;

  console.log("reconnecting in 5s...");

  reconnectTimeout = setTimeout(() => {
    connect("reconnecting");
  }, 5000);
}

connect("initial_configuration");//connected
 
 

function ajustarGeneralMain() {
	const emptyBlockContainer = document.querySelector('.empty-block-container');
	const generalMain = document.querySelector('.general-main');
	    if (window.innerWidth > 1000) {
	    const emptyHeight = emptyBlockContainer.offsetHeight;
	    generalMain.style.height = `calc(100vh - ${emptyHeight + 50}px)`; 
 
	} else {
	    generalMain.style.height = 'auto'; 
	}  

	ANCHO_VENTANA_VIRTUAL = window.innerWidth;
        contenedor.style.width = `${ANCHO_VENTANA_VIRTUAL}px`;
 
	if (fondoRegla) fondoRegla.style.width = `${ANCHO_VENTANA_VIRTUAL}px`;
	if (lineaRegla) lineaRegla.style.width = `${ANCHO_VENTANA_VIRTUAL}px`;
 

}
  
window.addEventListener('resize', ajustarGeneralMain);


 

 
 

</script>


<script src="../design2/general.js"> </script>
<script src="../design2/send_files.js"> </script> 
<script src="../design2/clipcontainer.js"> </script>  
<script src="../design2/htmlstring.js"> </script>  
<script src="../design2/expressions4.js"> </script>   
<script src="../design2/panel_tabs.js"> </script>  

</body>
</html>  
